---
phase: 01-add-core-abstractions
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - tests/viz/test_renderer_characterization.py
  - tests/viz/conftest.py
autonomous: true

must_haves:
  truths:
    - "Characterization tests document current render output structure"
    - "Tests capture node types, edge connections, and hierarchy"
    - "Golden files can be updated when behavior intentionally changes"
  artifacts:
    - path: "tests/viz/test_renderer_characterization.py"
      provides: "Golden master tests for renderer output"
      contains: "def test_"
    - path: "tests/viz/conftest.py"
      provides: "Shared fixtures for viz tests"
      contains: "pytest.fixture"
  key_links:
    - from: "tests/viz/test_renderer_characterization.py"
      to: "render_graph()"
      via: "pytest assertions on output structure"
      pattern: "render_graph.*assert"
---

<objective>
Create characterization tests that document current renderer behavior before Phase 2/3 changes.

Purpose: Provide safety net for refactoring. If edge routing changes in Phase 3 cause unexpected output changes, these tests will catch it. Golden files serve as documentation of expected behavior.

Output:
- Characterization tests for key graph structures
- Shared fixtures in conftest.py
- Clear process for updating golden files when behavior intentionally changes
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-add-core-abstractions/01-RESEARCH.md

# Previous plans establish the foundation
# After Plan 02, render_graph accepts NetworkX

@src/hypergraph/viz/renderer.py
@tests/viz/test_renderer.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared fixtures in conftest.py</name>
  <files>tests/viz/conftest.py</files>
  <action>
Create `tests/viz/conftest.py` with shared fixtures for visualization tests.

```python
"""Shared fixtures for visualization tests."""

import pytest
from hypergraph import Graph, node, route, ifelse, END


# === Simple Nodes ===

@node(output_name="doubled")
def double(x: int) -> int:
    """Double a number."""
    return x * 2


@node(output_name="tripled")
def triple(x: int) -> int:
    """Triple a number."""
    return x * 3


@node(output_name="result")
def add(a: int, b: int) -> int:
    """Add two numbers."""
    return a + b


@node(output_name="output")
def identity(value: int) -> int:
    """Pass through."""
    return value


# === Branch Nodes ===

@ifelse(when_true="double", when_false="triple")
def is_positive(x: int) -> bool:
    """Check if positive."""
    return x > 0


@route(targets=["double", "triple", END])
def router(x: int) -> str:
    """Route based on value."""
    if x > 0:
        return "double"
    elif x < 0:
        return "triple"
    return END


# === Graph Fixtures ===

@pytest.fixture
def simple_graph():
    """Single node graph."""
    return Graph(nodes=[double])


@pytest.fixture
def linear_graph():
    """Two connected nodes: double -> add."""
    @node(output_name="doubled")
    def double_local(x: int) -> int:
        return x * 2

    @node(output_name="result")
    def use_doubled(doubled: int, y: int) -> int:
        return doubled + y

    return Graph(nodes=[double_local, use_doubled])


@pytest.fixture
def branching_graph():
    """Graph with ifelse branch."""
    @node(output_name="doubled")
    def double_local(x: int) -> int:
        return x * 2

    @node(output_name="tripled")
    def triple_local(x: int) -> int:
        return x * 3

    @node(output_name="final")
    def combine(doubled: int = 0, tripled: int = 0) -> int:
        return doubled + tripled

    @ifelse(when_true="double_local", when_false="triple_local")
    def branch(x: int) -> bool:
        return x > 0

    return Graph(nodes=[branch, double_local, triple_local, combine])


@pytest.fixture
def nested_graph():
    """Graph with nested subgraph."""
    @node(output_name="inner_out")
    def inner_fn(inner_in: int) -> int:
        return inner_in * 2

    inner = Graph(nodes=[inner_fn], name="inner_graph")

    @node(output_name="outer_out")
    def outer_fn(x: int) -> int:
        return x + 1

    return Graph(nodes=[inner.as_node(), outer_fn])


@pytest.fixture
def double_nested_graph():
    """Graph with double nesting (graph inside graph inside graph)."""
    @node(output_name="deep_out")
    def deep_fn(deep_in: int) -> int:
        return deep_in * 2

    deep = Graph(nodes=[deep_fn], name="deep")

    @node(output_name="mid_out")
    def mid_fn(mid_in: int) -> int:
        return mid_in + 1

    mid = Graph(nodes=[deep.as_node(), mid_fn], name="mid")

    @node(output_name="outer_out")
    def outer_fn(x: int) -> int:
        return x - 1

    return Graph(nodes=[mid.as_node(), outer_fn])


@pytest.fixture
def bound_graph():
    """Graph with bound parameters."""
    return Graph(nodes=[add]).bind(a=5)


# === Utility Functions ===

def normalize_render_output(result: dict) -> dict:
    """Normalize render output for comparison.

    Removes non-deterministic fields (positions, styles) and sorts lists
    for stable comparison.
    """
    normalized = {
        "nodes": [],
        "edges": [],
        "meta": result.get("meta", {}),
    }

    # Normalize nodes
    for node in sorted(result["nodes"], key=lambda n: n["id"]):
        norm_node = {
            "id": node["id"],
            "type": node.get("type"),
            "data": {
                k: v for k, v in node.get("data", {}).items()
                if k not in ("theme",)  # Exclude theme as it varies
            },
        }
        if "parentNode" in node:
            norm_node["parentNode"] = node["parentNode"]
        normalized["nodes"].append(norm_node)

    # Normalize edges
    for edge in sorted(result["edges"], key=lambda e: e["id"]):
        norm_edge = {
            "id": edge["id"],
            "source": edge["source"],
            "target": edge["target"],
            "data": edge.get("data", {}),
        }
        normalized["edges"].append(norm_edge)

    return normalized
```
  </action>
  <verify>
```bash
uv run python -c "
from tests.viz.conftest import simple_graph, nested_graph, normalize_render_output
# Fixtures are pytest fixtures, test import works
print('conftest imports OK')
"
```
  </verify>
  <done>
- conftest.py created with graph fixtures
- Fixtures cover: simple, linear, branching, nested, double-nested, bound graphs
- normalize_render_output utility removes non-deterministic fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Create characterization tests</name>
  <files>tests/viz/test_renderer_characterization.py</files>
  <action>
Create `tests/viz/test_renderer_characterization.py` with characterization tests.

These tests document the current behavior. They don't use golden files (which add complexity) but instead assert on the structural properties of the output.

```python
"""Characterization tests for renderer output.

These tests document the current render_graph behavior. They serve as a safety net
during refactoring - if output structure changes unexpectedly, these tests fail.

To update when behavior intentionally changes:
1. Run tests to see what changed
2. Update assertions to match new expected behavior
3. Document why the change was made in commit message
"""

import pytest
from hypergraph.viz.renderer import render_graph


class TestSimpleGraphCharacterization:
    """Characterization tests for simple graphs."""

    def test_single_node_structure(self, simple_graph):
        """Document: single node produces INPUT_GROUP, FUNCTION, and DATA nodes."""
        result = render_graph(simple_graph.to_viz_graph())

        node_types = {n["data"]["nodeType"] for n in result["nodes"]}
        assert node_types == {"INPUT_GROUP", "FUNCTION", "DATA"}

        # Function node
        fn_nodes = [n for n in result["nodes"] if n["data"]["nodeType"] == "FUNCTION"]
        assert len(fn_nodes) == 1
        assert fn_nodes[0]["id"] == "double"
        assert fn_nodes[0]["data"]["label"] == "double"

        # DATA node for output
        data_nodes = [n for n in result["nodes"] if n["data"]["nodeType"] == "DATA"]
        assert len(data_nodes) == 1
        assert data_nodes[0]["data"]["label"] == "doubled"
        assert data_nodes[0]["data"]["sourceId"] == "double"

        # INPUT_GROUP for external input
        input_nodes = [n for n in result["nodes"] if n["data"]["nodeType"] == "INPUT_GROUP"]
        assert len(input_nodes) == 1
        assert "x" in input_nodes[0]["data"]["params"]

    def test_single_node_edges(self, simple_graph):
        """Document: edges connect INPUT_GROUP -> FUNCTION -> DATA."""
        result = render_graph(simple_graph.to_viz_graph())

        # Edge from INPUT_GROUP to function
        input_edges = [e for e in result["edges"]
                      if e["source"].startswith("__inputs")]
        assert len(input_edges) == 1
        assert input_edges[0]["target"] == "double"

        # Edge from function to DATA
        output_edges = [e for e in result["edges"]
                       if e.get("data", {}).get("edgeType") == "output"]
        assert len(output_edges) == 1
        assert output_edges[0]["source"] == "double"
        assert output_edges[0]["target"] == "data_double_doubled"


class TestLinearGraphCharacterization:
    """Characterization tests for linear (chain) graphs."""

    def test_linear_graph_data_flow(self, linear_graph):
        """Document: data edges flow through DATA nodes."""
        result = render_graph(linear_graph.to_viz_graph())

        # Find the data edge (not output edge)
        data_edges = [e for e in result["edges"]
                     if e.get("data", {}).get("edgeType") == "data"]

        # Should have edge from doubled DATA node to use_doubled
        doubled_to_consumer = [e for e in data_edges
                              if "doubled" in e["source"]]
        assert len(doubled_to_consumer) == 1


class TestBranchingGraphCharacterization:
    """Characterization tests for branching graphs."""

    def test_branch_node_type(self, branching_graph):
        """Document: ifelse nodes are rendered as BRANCH type."""
        result = render_graph(branching_graph.to_viz_graph())

        branch_nodes = [n for n in result["nodes"]
                       if n["data"]["nodeType"] == "BRANCH"]
        assert len(branch_nodes) == 1
        assert branch_nodes[0]["id"] == "branch"

    def test_branch_node_data(self, branching_graph):
        """Document: branch nodes include whenTrueTarget and whenFalseTarget."""
        result = render_graph(branching_graph.to_viz_graph())

        branch_node = next(n for n in result["nodes"]
                         if n["data"]["nodeType"] == "BRANCH")

        # Branch-specific data
        assert "whenTrueTarget" in branch_node["data"]
        assert "whenFalseTarget" in branch_node["data"]


class TestNestedGraphCharacterization:
    """Characterization tests for nested graphs."""

    def test_nested_expanded_structure(self, nested_graph):
        """Document: depth=1 expands nested graphs, children have parentNode."""
        result = render_graph(nested_graph.to_viz_graph(), depth=1)

        # Find pipeline node
        pipeline_nodes = [n for n in result["nodes"]
                        if n["data"]["nodeType"] == "PIPELINE"]
        assert len(pipeline_nodes) == 1
        assert pipeline_nodes[0]["data"]["isExpanded"] is True

        # Find children (nodes with parentNode)
        children = [n for n in result["nodes"] if "parentNode" in n]
        assert len(children) > 0

        # Children reference the pipeline as parent
        child_parents = {n["parentNode"] for n in children}
        assert "inner_graph" in child_parents

    def test_nested_collapsed_structure(self, nested_graph):
        """Document: depth=0 keeps nested graphs collapsed."""
        result = render_graph(nested_graph.to_viz_graph(), depth=0)

        pipeline_nodes = [n for n in result["nodes"]
                        if n["data"]["nodeType"] == "PIPELINE"]
        assert len(pipeline_nodes) == 1
        assert pipeline_nodes[0]["data"]["isExpanded"] is False

        # Children still present but marked for parent
        # (visibility controlled by JS)
        children = [n for n in result["nodes"] if "parentNode" in n]
        assert len(children) > 0


class TestDoubleNestedGraphCharacterization:
    """Characterization tests for double-nested graphs."""

    def test_double_nested_depth_2(self, double_nested_graph):
        """Document: depth=2 expands both nesting levels."""
        result = render_graph(double_nested_graph.to_viz_graph(), depth=2)

        pipeline_nodes = [n for n in result["nodes"]
                        if n["data"]["nodeType"] == "PIPELINE"]

        # Should have both mid and deep pipeline nodes
        pipeline_ids = {n["id"] for n in pipeline_nodes}
        assert "mid" in pipeline_ids
        # Note: deep is inside mid, check for nested child
        # The exact IDs depend on flattening approach in to_viz_graph

    def test_double_nested_parent_chain(self, double_nested_graph):
        """Document: parent chain is correctly established."""
        result = render_graph(double_nested_graph.to_viz_graph(), depth=2)

        # Build parent map
        parent_map = {n["id"]: n.get("parentNode") for n in result["nodes"]}

        # mid's parent is None (root level)
        assert parent_map.get("mid") is None

        # Check that nested nodes have correct parents
        # (exact structure depends on to_viz_graph implementation)


class TestBoundGraphCharacterization:
    """Characterization tests for graphs with bound parameters."""

    def test_bound_input_marked(self, bound_graph):
        """Document: bound inputs are marked in node data."""
        result = render_graph(bound_graph.to_viz_graph())

        fn_node = next(n for n in result["nodes"]
                      if n["data"]["nodeType"] == "FUNCTION")

        inputs = fn_node["data"]["inputs"]
        a_input = next(inp for inp in inputs if inp["name"] == "a")
        b_input = next(inp for inp in inputs if inp["name"] == "b")

        assert a_input["is_bound"] is True
        assert b_input["is_bound"] is False

    def test_bound_input_group_labeled(self, bound_graph):
        """Document: bound inputs get separate INPUT_GROUP with 'Bound' label."""
        result = render_graph(bound_graph.to_viz_graph())

        input_groups = [n for n in result["nodes"]
                       if n["data"]["nodeType"] == "INPUT_GROUP"]

        # Should have separate groups for bound and unbound
        labels = {n["data"]["label"] for n in input_groups}
        # One for unbound 'b', possibly one for bound 'a'
        assert "Inputs" in labels or "Bound" in labels


class TestMetaCharacterization:
    """Characterization tests for meta output."""

    def test_meta_includes_options(self, simple_graph):
        """Document: meta includes all rendering options."""
        result = render_graph(
            simple_graph.to_viz_graph(),
            depth=2,
            theme="dark",
            show_types=True,
            separate_outputs=True,
        )

        meta = result["meta"]
        assert meta["initial_depth"] == 2
        assert meta["theme_preference"] == "dark"
        assert meta["show_types"] is True
        assert meta["separate_outputs"] is True
```
  </action>
  <verify>
Run characterization tests:
```bash
uv run pytest tests/viz/test_renderer_characterization.py -v
```

All tests should pass, documenting current behavior.
  </verify>
  <done>
- Characterization tests created for all fixture types
- Tests document node structure, edge connections, nesting, bound params
- Tests serve as safety net for future refactoring
  </done>
</task>

</tasks>

<verification>
All tasks completed:

1. Run all viz tests:
   ```bash
   uv run pytest tests/viz/ -v
   ```
   All tests should pass.

2. Verify characterization tests cover key scenarios:
   ```bash
   uv run pytest tests/viz/test_renderer_characterization.py -v --collect-only
   ```
   Should show tests for: simple, linear, branching, nested, double-nested, bound graphs.

3. Verify fixtures work:
   ```bash
   uv run pytest tests/viz/test_renderer_characterization.py::TestSimpleGraphCharacterization -v
   ```
</verification>

<success_criteria>
1. conftest.py provides shared fixtures for common graph structures
2. Characterization tests document current render_graph output
3. Tests cover: simple, linear, branching, nested, double-nested, bound graphs
4. All tests pass with current implementation
5. Tests will fail if render output structure changes unexpectedly
</success_criteria>

<output>
After completion, create `.planning/phases/01-add-core-abstractions/01-03-SUMMARY.md`
</output>
