---
phase: 01-add-core-abstractions
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/hypergraph/viz/renderer.py
  - src/hypergraph/viz/__init__.py
autonomous: true

must_haves:
  truths:
    - "render_graph() accepts nx.DiGraph, not Graph object"
    - "No isinstance checks on HyperNode subclasses in renderer"
    - "Node type dispatch uses string-valued node_type attribute"
    - "Existing visualization behavior unchanged"
  artifacts:
    - path: "src/hypergraph/viz/renderer.py"
      provides: "NetworkX-only renderer"
      contains: "def render_graph"
    - path: "src/hypergraph/viz/__init__.py"
      provides: "Updated public API that calls to_viz_graph internally"
      contains: "to_viz_graph"
  key_links:
    - from: "src/hypergraph/viz/__init__.py"
      to: "Graph.to_viz_graph()"
      via: "visualize() calls to_viz_graph before render_graph"
      pattern: "to_viz_graph.*render_graph"
---

<objective>
Refactor renderer to consume NetworkX DiGraph instead of Graph domain object.

Purpose: Decouple visualization from hypergraph domain types. The renderer should read node attributes from the NetworkX graph, not perform isinstance checks on HyperNode subclasses.

Output:
- `render_graph()` signature changed to accept `nx.DiGraph`
- All isinstance checks removed from renderer
- `visualize()` function updated to call `graph.to_viz_graph()` before rendering
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-add-core-abstractions/01-RESEARCH.md

# Plan 01 creates the foundation this plan builds on
# After Plan 01 completes, Graph.to_viz_graph() will be available

# Current implementation to refactor
@src/hypergraph/viz/renderer.py
@src/hypergraph/viz/__init__.py
@src/hypergraph/graph/core.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor render_graph to accept NetworkX DiGraph</name>
  <files>src/hypergraph/viz/renderer.py</files>
  <action>
Refactor `render_graph()` to accept an `nx.DiGraph` instead of a `Graph` object.

**Changes:**

1. **Update function signature:**
   ```python
   def render_graph(
       viz_graph: nx.DiGraph,  # Changed from graph: Graph
       *,
       depth: int = 1,
       theme: str = "auto",
       show_types: bool = False,
       separate_outputs: bool = False,
   ) -> dict[str, Any]:
   ```

2. **Remove all imports of domain types:**
   Delete or comment out:
   ```python
   from hypergraph.nodes.base import HyperNode
   from hypergraph.nodes.function import FunctionNode
   from hypergraph.nodes.graph_node import GraphNode
   from hypergraph.nodes.gate import GateNode, RouteNode, IfElseNode, END
   ```
   Keep only:
   ```python
   import networkx as nx
   from typing import Any
   ```

3. **Delete `_get_node_type()` function** - node_type now comes from node attributes.

4. **Read input_spec from graph attributes:**
   ```python
   input_spec = viz_graph.graph.get('input_spec', {})
   bound_params = set(input_spec.get('bound', {}).keys())
   ```

5. **Iterate over nodes using NetworkX API:**
   ```python
   for node_id, node_attrs in viz_graph.nodes(data=True):
       node_type = node_attrs.get('node_type', 'FUNCTION')
       # ... build rf_node from node_attrs
   ```

6. **Replace all isinstance checks with attribute reads:**
   - `isinstance(hypernode, GraphNode)` -> `node_type == "PIPELINE"`
   - `isinstance(hypernode, IfElseNode)` -> check for `whenTrueTarget` in branch_data
   - `isinstance(hypernode, RouteNode)` -> check for `targets` in branch_data

7. **Read node properties from attrs:**
   ```python
   # OLD: hypernode.inputs
   # NEW: node_attrs.get('inputs', [])

   # OLD: hypernode.outputs
   # NEW: node_attrs.get('outputs', [])

   # OLD: hypernode.get_input_type(param)
   # NEW: node_attrs.get('input_types', {}).get(param)

   # OLD: hypernode.has_default_for(param)
   # NEW: node_attrs.get('has_defaults', {}).get(param, False)
   ```

8. **Handle nested graphs:**
   Nested graph nodes are already flattened in to_viz_graph() with `parent` attribute set.
   The recursive render_graph call is NO LONGER NEEDED - just iterate all nodes.
   Children have `parentNode` derived from their `parent` attribute.

9. **Build INPUT_GROUP nodes from input_spec:**
   ```python
   external_inputs = list(input_spec.get('required', [])) + list(input_spec.get('optional', []))
   # Build param_info by scanning nodes that consume each param
   for node_id, node_attrs in viz_graph.nodes(data=True):
       for param in node_attrs.get('inputs', []):
           if param in external_inputs:
               # Track target and type
   ```

10. **Edge iteration uses NetworkX:**
    ```python
    for source, target, edge_data in viz_graph.edges(data=True):
        edge_type = edge_data.get('edge_type', 'data')
        value_name = edge_data.get('value_name', '')
    ```

**Important:** The refactored function should produce IDENTICAL output for the same input graph. This is a pure refactor - behavior unchanged.
  </action>
  <verify>
Run all existing renderer tests:
```bash
uv run pytest tests/viz/test_renderer.py -v
```
All tests should pass. The test file imports `render_graph` and tests it with Graph objects - we'll update the test adapter in Task 2.
  </verify>
  <done>
- render_graph() accepts nx.DiGraph as first argument
- No imports from hypergraph.nodes.* in renderer.py
- All isinstance checks removed
- Node properties read from NetworkX node attributes
- Function output format unchanged
  </done>
</task>

<task type="auto">
  <name>Task 2: Update viz __init__.py to bridge old and new API</name>
  <files>src/hypergraph/viz/__init__.py</files>
  <action>
Update `src/hypergraph/viz/__init__.py` to call `to_viz_graph()` before passing to `render_graph()`.

The public `visualize()` function should:
1. Accept a `Graph` object (unchanged external API)
2. Call `graph.to_viz_graph()` to get NetworkX
3. Pass NetworkX to `render_graph()`

This maintains backward compatibility for callers.

**Read the current __init__.py first**, then modify the `visualize()` function:

```python
def visualize(
    graph: "Graph",
    *,
    width: int = 800,
    height: int = 600,
    depth: int = 1,
    theme: str = "auto",
    show_types: bool = False,
    output: str | None = None,
) -> Any:
    """Create an interactive visualization of a graph.

    Args:
        graph: The Graph object to visualize
        width: Widget width in pixels
        height: Widget height in pixels
        depth: Nested graph expansion depth
        theme: "dark", "light", or "auto"
        show_types: Show type annotations
        output: Path to save HTML (None for notebook display)
    """
    from .renderer import render_graph
    from .html_generator import generate_widget_html

    # Convert Graph to NetworkX for renderer
    viz_graph = graph.to_viz_graph()

    # Render to React Flow format
    graph_data = render_graph(
        viz_graph,
        depth=depth,
        theme=theme,
        show_types=show_types,
        separate_outputs=False,
    )

    # Generate HTML and display/save
    html_content = generate_widget_html(graph_data)

    if output:
        with open(output, "w") as f:
            f.write(html_content)
        return None

    # Return widget for notebook display
    from .widget import ScrollablePipelineWidget
    return ScrollablePipelineWidget(html_content, width=width, height=height)
```

Also update the test file `tests/viz/test_renderer.py` to call `to_viz_graph()` before `render_graph()`:

```python
# In each test method, change:
# result = render_graph(graph)
# To:
# result = render_graph(graph.to_viz_graph())
```

This is necessary because render_graph no longer accepts Graph objects directly.
  </action>
  <verify>
Run all viz tests:
```bash
uv run pytest tests/viz/ -v
```

Test the public API still works:
```python
from hypergraph import Graph, node
@node(output_name="y")
def f(x: int) -> int: return x
g = Graph([f])
# This should work via visualize() which calls to_viz_graph internally
# Can't test widget in CLI, but can test the render path
from hypergraph.viz.renderer import render_graph
result = render_graph(g.to_viz_graph())
assert 'nodes' in result
```
  </verify>
  <done>
- visualize() calls graph.to_viz_graph() before render_graph()
- Public API unchanged (still accepts Graph objects)
- Tests updated to pass NetworkX to render_graph()
- All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify no domain type imports in viz</name>
  <files>src/hypergraph/viz/renderer.py</files>
  <action>
Final verification task: ensure renderer.py has no imports from hypergraph.nodes or hypergraph.graph.

Run a grep to confirm:
```bash
grep -n "from hypergraph.nodes" src/hypergraph/viz/renderer.py
grep -n "from hypergraph.graph" src/hypergraph/viz/renderer.py
grep -n "isinstance" src/hypergraph/viz/renderer.py
```

All three commands should return empty (no matches).

If any matches found, remove them:
- Replace any remaining isinstance checks with attribute reads
- Remove any remaining node type imports

The only allowed imports in renderer.py should be:
- `from __future__ import annotations`
- `from typing import TYPE_CHECKING, Any` (TYPE_CHECKING can be removed if not needed)
- `import networkx as nx` (if using type hints)
- Standard library imports

Document in a comment at the top of the file:
```python
"""Render NetworkX visualization graph to React Flow JSON format.

This module transforms a NetworkX DiGraph (from Graph.to_viz_graph()) into the
React Flow node/edge format expected by the visualization.

IMPORTANT: This module must NOT import hypergraph domain types (nodes, graph).
All information comes from NetworkX node/edge attributes. This decoupling allows
the viz layer to evolve independently of the domain model.
"""
```
  </action>
  <verify>
```bash
# Verify no domain imports
! grep -q "from hypergraph.nodes" src/hypergraph/viz/renderer.py
! grep -q "from hypergraph.graph" src/hypergraph/viz/renderer.py
! grep -q "isinstance" src/hypergraph/viz/renderer.py

# Verify tests still pass
uv run pytest tests/viz/ -v
```
  </verify>
  <done>
- renderer.py has no imports from hypergraph.nodes.*
- renderer.py has no imports from hypergraph.graph.*
- renderer.py has no isinstance() calls
- Docstring documents the decoupling requirement
- All tests pass
  </done>
</task>

</tasks>

<verification>
All three tasks completed:

1. Renderer accepts NetworkX:
   ```bash
   uv run python -c "
   from hypergraph import Graph, node
   from hypergraph.viz.renderer import render_graph
   @node(output_name='y')
   def f(x: int) -> int: return x
   g = Graph([f])
   result = render_graph(g.to_viz_graph())
   print('Renderer OK:', 'nodes' in result)
   "
   ```

2. No domain imports:
   ```bash
   grep -c "isinstance" src/hypergraph/viz/renderer.py  # Should be 0
   grep -c "from hypergraph.nodes" src/hypergraph/viz/renderer.py  # Should be 0
   ```

3. All tests pass:
   ```bash
   uv run pytest tests/viz/ -v
   ```
</verification>

<success_criteria>
1. render_graph() signature accepts nx.DiGraph as first parameter
2. Zero isinstance() calls in renderer.py
3. Zero imports from hypergraph.nodes.* or hypergraph.graph.* in renderer.py
4. Public visualize() API unchanged (accepts Graph, calls to_viz_graph internally)
5. All existing tests pass with no behavioral changes
</success_criteria>

<output>
After completion, create `.planning/phases/01-add-core-abstractions/01-02-SUMMARY.md`
</output>
