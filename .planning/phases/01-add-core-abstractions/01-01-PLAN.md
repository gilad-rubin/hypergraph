---
phase: 01-add-core-abstractions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hypergraph/graph/core.py
  - src/hypergraph/viz/traversal.py
  - src/hypergraph/viz/coordinates.py
autonomous: true

must_haves:
  truths:
    - "Graph.to_viz_graph() returns NetworkX DiGraph with all visualization attributes"
    - "Traversal helper handles hierarchy without manual depth tracking"
    - "Coordinate transforms are explicit about which space they operate in"
  artifacts:
    - path: "src/hypergraph/graph/core.py"
      provides: "to_viz_graph() method on Graph class"
      contains: "def to_viz_graph"
    - path: "src/hypergraph/viz/traversal.py"
      provides: "Hierarchy traversal utilities"
      exports: ["traverse_to_leaves", "get_children"]
    - path: "src/hypergraph/viz/coordinates.py"
      provides: "Coordinate space abstraction"
      exports: ["CoordinateSpace", "Point"]
  key_links:
    - from: "src/hypergraph/graph/core.py"
      to: "networkx.DiGraph"
      via: "to_viz_graph() method"
      pattern: "def to_viz_graph.*nx\\.DiGraph"
---

<objective>
Create foundation abstractions for viz decoupling: NetworkX serialization, hierarchy traversal, and coordinate spaces.

Purpose: Enable renderer to consume pure data structures instead of domain types, eliminating isinstance checks and manual depth tracking.

Output:
- `Graph.to_viz_graph()` method returning NetworkX with all viz attributes
- `traversal.py` with hierarchy traversal utilities
- `coordinates.py` with CoordinateSpace class
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-add-core-abstractions/01-RESEARCH.md

# Current implementation
@src/hypergraph/graph/core.py
@src/hypergraph/viz/renderer.py
@src/hypergraph/nodes/graph_node.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add to_viz_graph() method to Graph class</name>
  <files>src/hypergraph/graph/core.py</files>
  <action>
Add a `to_viz_graph()` method to the Graph class that returns an `nx.DiGraph` containing all visualization-needed attributes.

The method should:

1. Create a new nx.DiGraph
2. Add graph-level attributes:
   ```python
   G.graph['input_spec'] = {
       'required': list(self.inputs.required),
       'optional': list(self.inputs.optional),
       'seeds': list(self.inputs.seeds),
       'bound': dict(self.inputs.bound),
   }
   G.graph['name'] = self.name
   ```

3. For each node in self.nodes, add to G with attributes:
   - `node_type`: "PIPELINE" | "BRANCH" | "FUNCTION" (derive without isinstance - use duck typing: check for `.graph` attr for PIPELINE, `.targets` attr for gates)
   - `label`: node.name
   - `inputs`: list of input param names
   - `outputs`: list of output names
   - `input_types`: dict mapping param -> formatted type string (use _format_type helper)
   - `output_types`: dict mapping output -> formatted type string
   - `has_defaults`: dict mapping param -> bool
   - `parent`: None for top-level nodes (will be set during recursive flattening)
   - `branch_data`: dict with whenTrueTarget/whenFalseTarget for IfElseNode, or targets list for RouteNode

4. For GraphNode (detected by hasattr(node, 'graph')), recursively flatten children:
   - Call `node.graph.to_viz_graph()` to get inner NetworkX
   - Add all inner nodes to G with `parent` attr set to outer node's name
   - Prefix inner node IDs to avoid collisions: `{parent_name}__{inner_id}`
   - Add inner edges with prefixed IDs

5. Copy edges from self.nx_graph with their edge_type and value_name attributes

Helper function `_classify_node_type(node)` should use duck typing:
- `hasattr(node, 'graph')` -> "PIPELINE"
- `hasattr(node, 'targets')` -> "BRANCH"
- else -> "FUNCTION"

Do NOT import concrete node classes in the method - use duck typing only.
  </action>
  <verify>
Run existing tests: `uv run pytest tests/viz/test_renderer.py -v`
Verify to_viz_graph returns nx.DiGraph:
```python
from hypergraph import Graph, node
@node(output_name="y")
def f(x: int) -> int: return x
g = Graph([f])
viz_g = g.to_viz_graph()
assert isinstance(viz_g, nx.DiGraph)
assert 'input_spec' in viz_g.graph
assert 'f' in viz_g.nodes
```
  </verify>
  <done>
- Graph.to_viz_graph() returns nx.DiGraph
- Graph-level attrs include input_spec with required/optional/seeds/bound
- Node attrs include node_type, inputs, outputs, types, defaults, branch_data
- Nested graphs are flattened with parent references
- No isinstance checks on node types
  </done>
</task>

<task type="auto">
  <name>Task 2: Create traversal.py with hierarchy utilities</name>
  <files>src/hypergraph/viz/traversal.py</files>
  <action>
Create a new module `src/hypergraph/viz/traversal.py` with hierarchy traversal utilities.

Contents:

```python
"""Hierarchy traversal utilities for visualization.

Provides recursive traversal that handles depth automatically via predicates,
eliminating manual depth parameter passing.
"""

from __future__ import annotations
from typing import Iterator, Callable, Any
import networkx as nx


def get_children(G: nx.DiGraph, parent_id: str | None) -> list[str]:
    """Get direct children of a node in the hierarchy.

    Args:
        G: NetworkX graph with 'parent' node attributes
        parent_id: Parent node ID, or None for root-level nodes

    Returns:
        List of node IDs that have parent_id as their parent
    """
    return [
        node_id for node_id, attrs in G.nodes(data=True)
        if attrs.get('parent') == parent_id
    ]


def traverse_to_leaves(
    G: nx.DiGraph,
    node_id: str,
    should_expand: Callable[[str, dict], bool],
) -> Iterator[str]:
    """Recursively traverse hierarchy, yielding leaf nodes.

    The predicate function controls whether to recurse into a node's children.
    This eliminates manual depth tracking - the predicate encapsulates the logic.

    Args:
        G: NetworkX graph with 'parent' node attributes
        node_id: Starting node ID
        should_expand: Predicate (node_id, node_attrs) -> bool.
                      Returns True to recurse into children, False to yield this node.

    Yields:
        Node IDs. If should_expand returns False or node has no children,
        yields the node itself. Otherwise, yields its descendants recursively.

    Example:
        # Expand pipelines up to depth 2
        depth_remaining = [2]
        def expand_predicate(nid, attrs):
            if attrs.get('node_type') != 'PIPELINE':
                return False
            if depth_remaining[0] <= 0:
                return False
            depth_remaining[0] -= 1
            return True

        for leaf_id in traverse_to_leaves(G, root_id, expand_predicate):
            # Process leaf nodes
            pass
    """
    attrs = G.nodes[node_id]

    # Check if we should expand this node
    if not should_expand(node_id, attrs):
        yield node_id
        return

    # Get children of this node
    children = get_children(G, node_id)

    if not children:
        yield node_id
        return

    # Recurse into children
    for child_id in children:
        yield from traverse_to_leaves(G, child_id, should_expand)


def build_expansion_predicate(
    max_depth: int,
    node_type_key: str = 'node_type',
    expandable_type: str = 'PIPELINE',
) -> Callable[[str, dict], bool]:
    """Build a predicate that expands nodes up to a maximum depth.

    Args:
        max_depth: Maximum depth to expand (0 = no expansion)
        node_type_key: Attribute key for node type
        expandable_type: Node type value that can be expanded

    Returns:
        Predicate function for use with traverse_to_leaves
    """
    depth_remaining = [max_depth]

    def predicate(node_id: str, attrs: dict) -> bool:
        if attrs.get(node_type_key) != expandable_type:
            return False
        if depth_remaining[0] <= 0:
            return False
        depth_remaining[0] -= 1
        return True

    return predicate
```

Also add `__all__` export list and update `src/hypergraph/viz/__init__.py` to include the new module (add import but don't export publicly - internal use only).
  </action>
  <verify>
Create a simple test:
```python
import networkx as nx
from hypergraph.viz.traversal import get_children, traverse_to_leaves, build_expansion_predicate

G = nx.DiGraph()
G.add_node('root', node_type='PIPELINE', parent=None)
G.add_node('child1', node_type='FUNCTION', parent='root')
G.add_node('child2', node_type='FUNCTION', parent='root')

assert get_children(G, None) == ['root']
assert set(get_children(G, 'root')) == {'child1', 'child2'}

# With expansion
pred = build_expansion_predicate(max_depth=1)
leaves = list(traverse_to_leaves(G, 'root', pred))
assert set(leaves) == {'child1', 'child2'}
```
  </verify>
  <done>
- traversal.py exists with get_children, traverse_to_leaves, build_expansion_predicate
- Functions work with NetworkX graphs containing 'parent' attributes
- No manual depth parameters passed through recursion
  </done>
</task>

<task type="auto">
  <name>Task 3: Create coordinates.py with CoordinateSpace class</name>
  <files>src/hypergraph/viz/coordinates.py</files>
  <action>
Create a new module `src/hypergraph/viz/coordinates.py` with coordinate space abstractions.

This class makes coordinate transformations explicit, preventing bugs where offsets are applied multiple times or in the wrong space.

Contents:

```python
"""Coordinate space abstractions for visualization.

Explicit coordinate tracking prevents bugs from mixing coordinate spaces
or applying transformations multiple times.

Four coordinate spaces:
- layout: Position calculated by layout algorithm (relative to layout origin)
- parent: Position relative to parent node (for nested graphs)
- absolute: Position relative to root canvas (layout + all parent offsets)
- viewport: Position after React Flow zoom/pan transform
"""

from __future__ import annotations
from dataclasses import dataclass
from typing import Literal

Space = Literal["layout", "parent", "absolute", "viewport"]


@dataclass(frozen=True)
class Point:
    """Immutable 2D point."""
    x: float
    y: float

    def offset(self, dx: float, dy: float) -> "Point":
        """Return new point offset by (dx, dy)."""
        return Point(self.x + dx, self.y + dy)

    def __add__(self, other: "Point") -> "Point":
        """Add two points."""
        return Point(self.x + other.x, self.y + other.y)

    def __sub__(self, other: "Point") -> "Point":
        """Subtract two points."""
        return Point(self.x - other.x, self.y - other.y)


@dataclass(frozen=True)
class CoordinateSpace:
    """A 2D coordinate with explicit space tracking.

    Transformations between spaces are explicit methods, making it impossible
    to accidentally mix coordinates from different spaces.

    Example:
        # Layout algorithm gives us layout-space coordinates
        layout_pos = CoordinateSpace(100, 200, "layout")

        # Convert to parent-relative (for React Flow child positioning)
        parent_pos = layout_pos.to_parent(parent_offset=Point(50, 100))

        # Convert to absolute (for edge routing)
        absolute_pos = parent_pos.to_absolute(ancestors=[Point(50, 100)])
    """
    x: float
    y: float
    space: Space

    @property
    def point(self) -> Point:
        """Get the (x, y) as a Point."""
        return Point(self.x, self.y)

    def to_parent(self, parent_offset: Point) -> "CoordinateSpace":
        """Transform from layout space to parent-relative space.

        Args:
            parent_offset: Offset of parent node's content area origin

        Returns:
            New CoordinateSpace in parent space

        Raises:
            AssertionError: If not in layout space
        """
        assert self.space == "layout", f"Expected layout space, got {self.space}"
        return CoordinateSpace(
            self.x + parent_offset.x,
            self.y + parent_offset.y,
            "parent"
        )

    def to_absolute(self, ancestors: list[Point]) -> "CoordinateSpace":
        """Transform to absolute space by summing all ancestor offsets.

        Args:
            ancestors: List of ancestor offsets from root to parent

        Returns:
            New CoordinateSpace in absolute space

        Raises:
            AssertionError: If not in layout or parent space
        """
        assert self.space in ("layout", "parent"), f"Expected layout/parent space, got {self.space}"
        abs_x, abs_y = self.x, self.y
        for offset in ancestors:
            abs_x += offset.x
            abs_y += offset.y
        return CoordinateSpace(abs_x, abs_y, "absolute")

    def to_viewport(self, zoom: float, pan: Point) -> "CoordinateSpace":
        """Apply React Flow viewport transform (zoom, pan).

        Args:
            zoom: Viewport zoom level
            pan: Viewport pan offset

        Returns:
            New CoordinateSpace in viewport space

        Raises:
            AssertionError: If not in absolute space
        """
        assert self.space == "absolute", f"Expected absolute space, got {self.space}"
        return CoordinateSpace(
            self.x * zoom + pan.x,
            self.y * zoom + pan.y,
            "viewport"
        )


def layout_to_absolute(
    node_id: str,
    layout_positions: dict[str, Point],
    parent_map: dict[str, str | None],
) -> Point:
    """Convert layout-space position to absolute space.

    Utility function that walks up the parent chain to compute absolute position.

    Args:
        node_id: Target node
        layout_positions: Layout algorithm output (layout space)
        parent_map: Mapping of node_id -> parent_id (None for roots)

    Returns:
        Absolute position (sum of layout + all ancestor offsets)
    """
    layout_pos = layout_positions[node_id]
    abs_x, abs_y = layout_pos.x, layout_pos.y

    # Walk up parent chain
    current_id = parent_map.get(node_id)
    while current_id is not None:
        parent_pos = layout_positions[current_id]
        abs_x += parent_pos.x
        abs_y += parent_pos.y
        current_id = parent_map.get(current_id)

    return Point(abs_x, abs_y)
```

Add `__all__` export list. Update `src/hypergraph/viz/__init__.py` to include import (internal use only).
  </action>
  <verify>
Test coordinate transformations:
```python
from hypergraph.viz.coordinates import Point, CoordinateSpace, layout_to_absolute

# Test Point
p = Point(10, 20)
assert p.offset(5, -5) == Point(15, 15)

# Test CoordinateSpace transforms
layout = CoordinateSpace(100, 200, "layout")
parent = layout.to_parent(Point(50, 60))
assert parent.space == "parent"
assert parent.x == 150
assert parent.y == 260

absolute = parent.to_absolute([Point(10, 10)])
assert absolute.space == "absolute"
assert absolute.x == 160
assert absolute.y == 270

# Test layout_to_absolute
positions = {'root': Point(0, 0), 'child': Point(50, 50)}
parents = {'root': None, 'child': 'root'}
abs_pos = layout_to_absolute('child', positions, parents)
assert abs_pos == Point(50, 50)  # root at origin, so child's absolute = layout
```
  </verify>
  <done>
- coordinates.py exists with Point, CoordinateSpace, layout_to_absolute
- CoordinateSpace tracks space explicitly (layout/parent/absolute/viewport)
- Transforms assert correct input space before transforming
- Functions are immutable (return new objects)
  </done>
</task>

</tasks>

<verification>
All three tasks completed:
1. `uv run python -c "from hypergraph import Graph, node; from hypergraph.graph.core import Graph; g = Graph([node(output_name='y')(lambda x: x)]); print(type(g.to_viz_graph()))"`
   Should print: `<class 'networkx.classes.digraph.DiGraph'>`

2. `uv run python -c "from hypergraph.viz.traversal import get_children, traverse_to_leaves, build_expansion_predicate; print('traversal OK')"`
   Should print: `traversal OK`

3. `uv run python -c "from hypergraph.viz.coordinates import Point, CoordinateSpace; print('coordinates OK')"`
   Should print: `coordinates OK`

4. Existing tests still pass: `uv run pytest tests/viz/ -v`
</verification>

<success_criteria>
1. Graph.to_viz_graph() returns nx.DiGraph with input_spec in graph attrs
2. Node attrs contain node_type derived without isinstance checks
3. traversal.py provides hierarchy traversal without manual depth params
4. coordinates.py provides explicit coordinate space tracking
5. All existing viz tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/01-add-core-abstractions/01-01-SUMMARY.md`
</output>
