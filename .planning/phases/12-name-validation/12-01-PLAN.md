---
phase: 12-name-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [tests/test_graph_validation.py]
autonomous: true

must_haves:
  truths:
    - "Names starting with underscore (_private) are accepted as valid"
    - "Names that are Python keywords are rejected with clear error"
    - "Empty string names are rejected with clear error"
    - "Unicode characters in names are handled correctly"
    - "Very long names (1000+ chars) are handled correctly"
  artifacts:
    - path: "tests/test_graph_validation.py"
      provides: "Name validation edge case tests"
      contains: "class TestNameValidationEdgeCases"
  key_links:
    - from: "tests/test_graph_validation.py"
      to: "src/hypergraph/graph.py"
      via: "test methods triggering _validate_valid_identifiers"
      pattern: "Graph\\(.*\\)|GraphConfigError"
---

<objective>
Test name validation edge cases to ensure the graph construction handles unusual but valid names correctly and rejects truly invalid names with clear errors.

Purpose: Verify that node names and output names are properly validated for Python identifier rules plus additional constraints (keywords, empty strings).

Output: New test class `TestNameValidationEdgeCases` in tests/test_graph_validation.py with comprehensive tests covering all NAME requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md

Source files:
@src/hypergraph/graph.py (see _validate_valid_identifiers method around line 410)
@tests/test_graph_validation.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TestNameValidationEdgeCases test class</name>
  <files>tests/test_graph_validation.py</files>
  <action>
Add new test class `TestNameValidationEdgeCases` at the end of the file to test name validation edge cases.

**Tests to create:**

**NAME-01: Underscore prefix names (should be accepted)**

1. **test_node_name_with_leading_underscore_valid** - `_private` is valid Python identifier
   - Create FunctionNode, set name to `"_private"`
   - Wrap in Graph
   - Assert no error raised, node exists in graph

2. **test_output_name_with_leading_underscore_valid** - `_result` is valid
   - Create `@node(output_name="_result")`
   - Wrap in Graph
   - Assert no error, output exists

3. **test_node_name_double_underscore_valid** - `__dunder__` is valid
   - Test with dunder-style name
   - Assert accepted

**NAME-02: Python keywords (should be rejected)**

4. **test_node_name_keyword_class_raises** - `class` is a Python keyword
   - Create FunctionNode, set name to `"class"`
   - Attempt to wrap in Graph
   - Assert GraphConfigError raised with "keyword" in message
   - NOTE: Current implementation may NOT reject this - test documents expected behavior

5. **test_node_name_keyword_for_raises** - `for` is a Python keyword
   - Same pattern with `"for"`

6. **test_node_name_keyword_import_raises** - `import` is a Python keyword
   - Same pattern with `"import"`

7. **test_output_name_keyword_raises** - Output names should reject keywords too
   - Create `@node(output_name="class")`
   - Assert GraphConfigError raised

**NAME-03: Empty string names (should be rejected)**

8. **test_node_name_empty_string_raises** - Empty string is not valid identifier
   - Create FunctionNode, set name to `""`
   - Attempt to wrap in Graph
   - Assert GraphConfigError raised with "Invalid node name" in message

9. **test_output_name_empty_string_raises** - Empty output name rejected
   - Create `@node(output_name="")`
   - Assert GraphConfigError raised

**NAME-04: Unicode characters**

10. **test_node_name_unicode_valid_identifier** - Valid unicode identifiers work
    - Create FunctionNode with name `"cafe"` (no accents, plain ASCII as baseline)
    - Assert accepted

11. **test_node_name_unicode_greek_letter** - Greek letters are valid identifiers
    - Create FunctionNode with name containing valid unicode: `"alpha"` then try `"\u03b1"` (Greek alpha)
    - Assert accepted (Python allows unicode identifiers)

12. **test_node_name_unicode_emoji_raises** - Emojis are not valid identifiers
    - Create FunctionNode with name containing emoji
    - Assert GraphConfigError raised

13. **test_node_name_unicode_space_raises** - Unicode spaces are not valid
    - Create FunctionNode with name containing non-breaking space `"\u00a0"`
    - Assert GraphConfigError raised

**NAME-05: Very long names (1000+ chars)**

14. **test_node_name_very_long_valid** - 1000+ char name that is valid identifier
    - Create FunctionNode with name `"a" * 1000`
    - Wrap in Graph
    - Assert accepted (Python has no length limit on identifiers)

15. **test_output_name_very_long_valid** - Long output names accepted
    - Create `@node(output_name="x" * 1000)`
    - Assert accepted

16. **test_error_message_with_long_name_readable** - Error messages truncate long names
    - Create invalid long name (e.g., `"1" + "a" * 1000` starts with digit)
    - Assert GraphConfigError raised
    - Assert error message is readable (not 1000+ chars of garbage)

**Implementation notes:**
- Use existing pattern: `func.name = "..."` to set custom names on FunctionNode
- Import `keyword` module to get list of Python keywords
- Tests that verify current behavior may expose gaps in implementation (expected)
- Follow existing docstring and assertion patterns from TestNodeAndOutputNameValidation
  </action>
  <verify>uv run pytest tests/test_graph_validation.py::TestNameValidationEdgeCases -v</verify>
  <done>
- TestNameValidationEdgeCases class exists with 16 test methods
- Underscore tests (3) verify valid names accepted
- Keyword tests (4) verify keywords rejected (may fail if not implemented)
- Empty string tests (2) verify empty names rejected
- Unicode tests (4) verify correct handling
- Long name tests (3) verify no artificial length limits
- All tests run without syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify test results and document gaps</name>
  <files>tests/test_graph_validation.py</files>
  <action>
Run the full test suite and analyze which tests pass/fail.

**Expected outcomes:**
- Underscore tests: Should PASS (Python's isidentifier accepts these)
- Keyword tests: May FAIL (current code uses only isidentifier, not keyword.iskeyword)
- Empty string tests: Should PASS (isidentifier rejects empty strings)
- Unicode tests: Should PASS/FAIL based on Python's identifier rules
- Long name tests: Should PASS (no length limit in Python identifiers)

**If keyword tests fail:**
This is expected - the test documents that the implementation should check for keywords but currently does not. Do NOT modify the implementation in this plan. The test serves to document the expected behavior.

Add a comment at the top of TestNameValidationEdgeCases:

```python
class TestNameValidationEdgeCases:
    """Test name validation edge cases.

    Note: Some tests document expected behavior that may not be implemented yet.
    Tests for Python keyword rejection (NAME-02) may fail until implementation
    is updated to use keyword.iskeyword() in addition to str.isidentifier().
    """
```

**If tests reveal implementation needs updating:**
Add pytest.mark.xfail to tests that fail due to missing implementation:

```python
@pytest.mark.xfail(reason="Implementation doesn't check for Python keywords yet")
def test_node_name_keyword_class_raises(self):
    ...
```

This marks them as known gaps without breaking the test suite.
  </action>
  <verify>uv run pytest tests/test_graph_validation.py -v --tb=short</verify>
  <done>
- All tests run without syntax errors
- Passing tests confirm working functionality
- Failing tests marked with xfail if they document gaps
- Test class has docstring explaining expected behavior vs current state
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/test_graph_validation.py::TestNameValidationEdgeCases -v` runs all tests
- [ ] No syntax errors in test file
- [ ] Test class follows existing patterns (docstrings, assertion style)
- [ ] Tests cover all 5 NAME requirements (NAME-01 through NAME-05)
- [ ] Gaps documented with xfail markers or comments
</verification>

<success_criteria>

- TestNameValidationEdgeCases class exists with 16 test methods
- Tests cover: underscore names, Python keywords, empty strings, unicode, long names
- Tests that pass confirm working validation
- Tests that fail are marked xfail (documents gaps for future implementation)
- Error messages tested for readability with long names
- No syntax errors or broken imports
</success_criteria>

<output>
After completion, create `.planning/phases/12-name-validation/12-01-SUMMARY.md`
</output>
