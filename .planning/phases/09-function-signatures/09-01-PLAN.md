---
phase: 09-function-signatures
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [tests/test_nodes_function.py]
autonomous: true

must_haves:
  truths:
    - "FunctionNode.inputs includes *args parameter name"
    - "FunctionNode.inputs includes **kwargs parameter name"
    - "FunctionNode.inputs includes keyword-only parameters"
    - "FunctionNode.inputs includes positional-only parameters"
    - "FunctionNode correctly handles functions with mixed parameter types"
    - "FunctionNode.defaults works correctly with keyword-only and positional-only params"
    - "FunctionNode.parameter_annotations works with all parameter kinds"
  artifacts:
    - path: "tests/test_nodes_function.py"
      provides: "Function signature tests"
      contains: "class TestFunctionSignatures"
  key_links:
    - from: "tests/test_nodes_function.py"
      to: "src/hypergraph/nodes/function.py"
      via: "test methods verifying inputs, defaults, parameter_annotations"
      pattern: "\.inputs|\.defaults|\.parameter_annotations"
---

<objective>
Test FunctionNode handles all Python parameter types: *args, **kwargs, keyword-only (*, name), positional-only (param, /), and mixed combinations.

Purpose: Verify FunctionNode correctly extracts inputs, defaults, and type annotations from functions with complex signatures. These are edge cases not covered by existing tests which only use standard POSITIONAL_OR_KEYWORD parameters.

Output: New test class `TestFunctionSignatures` in tests/test_nodes_function.py covering all 5 FUNC requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

Source files:
@src/hypergraph/nodes/function.py
@tests/test_nodes_function.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TestFunctionSignatures test class for basic parameter kinds</name>
  <files>tests/test_nodes_function.py</files>
  <action>
Add new test class `TestFunctionSignatures` at the end of the file to test all Python parameter types.

**Background:** Python has 5 parameter kinds (from inspect.Parameter.kind):
- POSITIONAL_ONLY: `def f(a, /)`
- POSITIONAL_OR_KEYWORD: `def f(a)` (standard, already tested)
- VAR_POSITIONAL: `def f(*args)`
- KEYWORD_ONLY: `def f(*, kw)`
- VAR_KEYWORD: `def f(**kwargs)`

FunctionNode extracts inputs via `inspect.signature(func).parameters.keys()` which includes ALL parameter names regardless of kind.

**Tests to create for FUNC-01 (*args):**

1. **test_var_positional_in_inputs** - *args parameter appears in inputs
   ```python
   def foo(*args):
       pass
   fn = FunctionNode(foo)
   assert "args" in fn.inputs
   assert fn.inputs == ("args",)
   ```

2. **test_var_positional_no_default** - *args has no default
   ```python
   def foo(*args):
       pass
   fn = FunctionNode(foo)
   assert fn.defaults == {}
   assert not fn.has_default_for("args")
   ```

3. **test_var_positional_with_annotation** - *args can have type annotation
   ```python
   def foo(*args: int):
       pass
   fn = FunctionNode(foo)
   # Note: get_type_hints returns tuple[int, ...] for *args: int
   # This may or may not be in parameter_annotations depending on implementation
   ```

**Tests to create for FUNC-02 (**kwargs):**

4. **test_var_keyword_in_inputs** - **kwargs parameter appears in inputs
   ```python
   def foo(**kwargs):
       pass
   fn = FunctionNode(foo)
   assert "kwargs" in fn.inputs
   assert fn.inputs == ("kwargs",)
   ```

5. **test_var_keyword_no_default** - **kwargs has no default
   ```python
   def foo(**kwargs):
       pass
   fn = FunctionNode(foo)
   assert fn.defaults == {}
   assert not fn.has_default_for("kwargs")
   ```

**Tests to create for FUNC-03 (keyword-only):**

6. **test_keyword_only_in_inputs** - keyword-only params appear in inputs
   ```python
   def foo(a, *, kw):
       pass
   fn = FunctionNode(foo)
   assert fn.inputs == ("a", "kw")
   ```

7. **test_keyword_only_with_default** - keyword-only can have defaults
   ```python
   def foo(a, *, kw=10):
       pass
   fn = FunctionNode(foo)
   assert fn.defaults == {"kw": 10}
   assert fn.has_default_for("kw")
   assert fn.get_default_for("kw") == 10
   ```

8. **test_keyword_only_without_default** - keyword-only without default
   ```python
   def foo(a, *, kw):
       pass
   fn = FunctionNode(foo)
   assert "kw" not in fn.defaults
   assert not fn.has_default_for("kw")
   ```

9. **test_keyword_only_with_annotation** - keyword-only with type annotation
   ```python
   def foo(a, *, kw: str):
       pass
   fn = FunctionNode(foo)
   assert fn.parameter_annotations.get("kw") == str
   ```

**Tests to create for FUNC-04 (positional-only):**

10. **test_positional_only_in_inputs** - positional-only params appear in inputs
    ```python
    def foo(a, /, b):
        pass
    fn = FunctionNode(foo)
    assert fn.inputs == ("a", "b")
    ```

11. **test_positional_only_with_default** - positional-only can have defaults
    ```python
    def foo(a=5, /, b=10):
        pass
    fn = FunctionNode(foo)
    assert fn.defaults == {"a": 5, "b": 10}
    ```

12. **test_positional_only_with_annotation** - positional-only with type annotation
    ```python
    def foo(a: int, /) -> str:
        pass
    fn = FunctionNode(foo)
    assert fn.parameter_annotations.get("a") == int
    ```

**Pattern:** Follow existing test style (pytest, docstrings, self-contained tests).
  </action>
  <verify>uv run pytest tests/test_nodes_function.py::TestFunctionSignatures -v</verify>
  <done>
- TestFunctionSignatures class exists with 12 test methods
- Tests cover *args (FUNC-01), **kwargs (FUNC-02), keyword-only (FUNC-03), positional-only (FUNC-04)
- Tests verify inputs, defaults, has_default_for, parameter_annotations
- All tests run without syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for mixed argument types (FUNC-05)</name>
  <files>tests/test_nodes_function.py</files>
  <action>
Add tests for FUNC-05: FunctionNode handles mixed argument types correctly.

**Add to TestFunctionSignatures:**

13. **test_mixed_all_param_kinds** - Function with all parameter kinds
    ```python
    def foo(pos_only, /, regular, *args, kw_only, **kwargs):
        pass
    fn = FunctionNode(foo)
    assert fn.inputs == ("pos_only", "regular", "args", "kw_only", "kwargs")
    ```

14. **test_mixed_with_defaults** - Mixed params with various defaults
    ```python
    def foo(pos=1, /, reg=2, *args, kw=3, **kwargs):
        pass
    fn = FunctionNode(foo)
    assert fn.defaults == {"pos": 1, "reg": 2, "kw": 3}
    # *args and **kwargs never have defaults
    assert "args" not in fn.defaults
    assert "kwargs" not in fn.defaults
    ```

15. **test_mixed_with_annotations** - Mixed params with type annotations
    ```python
    def foo(pos: int, /, reg: str, *args: float, kw: bool, **kwargs: dict) -> list:
        pass
    fn = FunctionNode(foo, output_name="result")
    # Verify standard params are annotated
    assert fn.parameter_annotations.get("pos") == int
    assert fn.parameter_annotations.get("reg") == str
    assert fn.parameter_annotations.get("kw") == bool
    # Note: *args and **kwargs annotations may or may not appear
    # depending on how get_type_hints handles them
    ```

16. **test_mixed_rename_works** - rename_inputs works with mixed param kinds
    ```python
    def foo(a, /, b, *, c):
        pass
    fn = FunctionNode(foo, rename_inputs={"a": "x", "b": "y", "c": "z"})
    assert fn.inputs == ("x", "y", "z")
    ```

17. **test_mixed_callable** - Mixed-signature function is still callable
    ```python
    def foo(a, /, b, *args, c, **kwargs):
        return (a, b, args, c, kwargs)
    fn = FunctionNode(foo, output_name="result")
    result = fn(1, 2, 3, 4, c=5, extra=6)
    assert result == (1, 2, (3, 4), 5, {"extra": 6})
    ```

18. **test_only_var_args_and_kwargs** - Function with just *args and **kwargs
    ```python
    def foo(*args, **kwargs):
        pass
    fn = FunctionNode(foo)
    assert fn.inputs == ("args", "kwargs")
    assert fn.defaults == {}
    ```

19. **test_keyword_only_multiple** - Multiple keyword-only params
    ```python
    def foo(*, a, b=1, c):
        pass
    fn = FunctionNode(foo)
    assert fn.inputs == ("a", "b", "c")
    assert fn.defaults == {"b": 1}
    ```

20. **test_positional_only_multiple** - Multiple positional-only params
    ```python
    def foo(a, b, c, /):
        pass
    fn = FunctionNode(foo)
    assert fn.inputs == ("a", "b", "c")
    ```

**Pattern:** Each test is self-contained. Verify both the mechanical aspects (inputs tuple) and semantic behavior (callable, defaults work).
  </action>
  <verify>uv run pytest tests/test_nodes_function.py::TestFunctionSignatures -v</verify>
  <done>
- 8 additional tests for mixed argument types (FUNC-05)
- Tests verify complex signature combinations work correctly
- Tests verify rename_inputs works with all param kinds
- Tests verify callable behavior preserved
- All 20 tests run without errors
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/test_nodes_function.py::TestFunctionSignatures -v` runs all 20 tests
- [ ] `uv run pytest tests/test_nodes_function.py -v` all existing tests still pass (81 total expected)
- [ ] No syntax errors in test file
- [ ] Test class follows existing patterns (class docstring, test docstrings)
- [ ] Tests cover all 5 FUNC requirements (FUNC-01 through FUNC-05)
</verification>

<success_criteria>

- TestFunctionSignatures class exists with 20 test methods
- Tests document current behavior for all Python parameter kinds
- Tests cover: *args, **kwargs, keyword-only, positional-only, mixed combinations
- Tests verify inputs, defaults, has_default_for, get_default_for, parameter_annotations
- All tests pass (documenting that FunctionNode already handles these correctly)
- No regressions in existing 61 tests
</success_criteria>

<output>
After completion, create `.planning/phases/09-function-signatures/09-01-SUMMARY.md`
</output>
