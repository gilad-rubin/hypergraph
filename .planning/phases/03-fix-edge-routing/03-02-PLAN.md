---
phase: 03-fix-edge-routing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/hypergraph/viz/assets/constraint-layout.js
  - src/hypergraph/viz/assets/layout.js
autonomous: true

must_haves:
  truths:
    - "Edges route around nodes, never through them"
    - "Target row blocking detection includes all rows between source and target"
    - "Collapsed nested graphs have edges connecting flush to boundary"
    - "Double-nested graphs route edges to correct inner nodes"
  artifacts:
    - path: "src/hypergraph/viz/assets/constraint-layout.js"
      provides: "Fixed blocking detection in routing function"
      contains: "target.row"
    - path: "src/hypergraph/viz/assets/layout.js"
      provides: "Edge routing using absolute positions"
      contains: "absolutePositions"
  key_links:
    - from: "routing function"
      to: "absolutePositions"
      via: "position lookup for edge routing"
      pattern: "absolutePositions\\.get"
---

<objective>
Fix the edge routing algorithm to correctly route around nodes at all nesting depths by using absolute coordinates and fixing the target row blocking detection.

Purpose: This plan addresses EDGE-01 through EDGE-04 by fixing the actual bugs identified in research: target row not checked for blocking, edges using wrong coordinate space for nested nodes.

Output: Working edge routing that handles arbitrary nesting depth without edges crossing nodes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-fix-edge-routing/03-RESEARCH.md

# Prior plan in this phase
@.planning/phases/03-fix-edge-routing/03-01-SUMMARY.md

# Key source files
@src/hypergraph/viz/assets/constraint-layout.js
@src/hypergraph/viz/assets/layout.js
@src/hypergraph/viz/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix target row blocking detection in constraint-layout.js</name>
  <files>src/hypergraph/viz/assets/constraint-layout.js</files>
  <action>
The research identified a critical bug: the routing function checks `i < target.row` which misses blocking nodes in the target's row. Fix the blocking detection loop in the `routing` function.

Find the blocking detection loop (around line 587):
```javascript
for (let i = source.row + 1; i < target.row; i += 1) {
```

Change it to include the target row, but skip the target node itself:
```javascript
// Include target row in blocking detection (fixes edge-over-node regression)
// Must check all rows between source and target, including target's row
for (let i = source.row + 1; i <= target.row; i += 1) {
  let rowBlocks = false;
  for (const node of rows[i]) {
    // Skip the target node itself - we want to route TO it, not around it
    if (node === target) continue;

    // Check if this node blocks the natural path
    if (naturalX >= nodeLeft(node) - spaceX * 0.5 &&
        naturalX <= nodeRight(node) + spaceX * 0.5) {
      rowBlocks = true;
      break;
    }
  }

  if (rowBlocks) {
    if (firstBlockedRow === -1) firstBlockedRow = i;
    lastBlockedRow = i;
    blockedRows.push(i);
  }
}
```

Similarly, update the node bounds calculation to skip target node when computing corridor positions (around line 625):
```javascript
for (const rowIdx of blockedRows) {
  for (const node of rows[rowIdx]) {
    // Skip target node when calculating bounds
    if (node === target) continue;
    globalNodeLeft = Math.min(globalNodeLeft, nodeLeft(node));
    globalNodeRight = Math.max(globalNodeRight, nodeRight(node));
  }
}
```

This ensures edges route AROUND nodes in the target row while still connecting TO the target node.
  </action>
  <verify>
Run: `grep -n "target.row" src/hypergraph/viz/assets/constraint-layout.js`
Should show `i <= target.row` (inclusive) instead of `i < target.row`.

Run: `grep -n "node === target" src/hypergraph/viz/assets/constraint-layout.js`
Should show the target node skip logic in both the blocking check and bounds calculation.
  </verify>
  <done>
Blocking detection loop checks all rows including target row, skips target node itself.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update edge routing to use absolute positions for nested graphs</name>
  <files>src/hypergraph/viz/assets/layout.js</files>
  <action>
The current edge routing in performRecursiveLayout transforms edge points using inline arithmetic. Update it to use the absolutePositions from Task 2 of Plan 01.

Find the child edge positioning section (around line 698 in performRecursiveLayout):
```javascript
childResult.edges.forEach(function(e) {
  var offsetPoints = (e.points || []).map(function(pt) {
    return {
      x: pt.x - layoutPadding + absOffsetX,
      y: pt.y - layoutPadding + absOffsetY
    };
  });
```

Update to use absolute positions and CoordinateTransform:
```javascript
childResult.edges.forEach(function(e) {
  // Get source and target absolute positions for edge endpoint calculation
  var sourceAbsPos = absolutePositions.get(e.source);
  var targetAbsPos = absolutePositions.get(e.target);

  // Transform edge waypoints from layout space to absolute viewport space
  var offsetPoints = (e.points || []).map(function(pt) {
    // Points from constraint layout are in the same coordinate system as nodes
    // Transform using the same offset as child nodes
    return {
      x: pt.x - layoutPadding + absOffsetX,
      y: pt.y - layoutPadding + absOffsetY
    };
  });

  // Store absolute positions on edge data for CustomEdge to use
  allPositionedEdges.push({
    ...e._original,
    data: {
      ...e._original.data,
      points: offsetPoints,
      // Store absolute endpoints for edge rendering
      _sourceAbsPos: sourceAbsPos,
      _targetAbsPos: targetAbsPos
    },
  });
});
```

Also update root edge positioning to include absolute positions:
```javascript
rootResult.edges.forEach(function(e) {
  var sourceAbsPos = absolutePositions.get(e.source);
  var targetAbsPos = absolutePositions.get(e.target);

  allPositionedEdges.push({
    ...e._original,
    data: {
      ...e._original.data,
      points: e.points,
      _sourceAbsPos: sourceAbsPos,
      _targetAbsPos: targetAbsPos
    },
  });
});
```

This ensures edges have access to the correct absolute positions for their endpoints, regardless of nesting depth.
  </action>
  <verify>
Run: `grep -n "_sourceAbsPos\|_targetAbsPos" src/hypergraph/viz/assets/layout.js`
Should show absolute position storage for both root and child edges.
  </verify>
  <done>
Edge data includes absolute source and target positions for correct rendering at any nesting depth.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run comprehensive viz tests and verify edge routing</name>
  <files>tests/viz/test_renderer.py</files>
  <action>
Run all viz tests to verify the edge routing fixes work correctly:

```bash
uv run pytest tests/viz/test_renderer.py -v
```

Then manually verify with the test notebook if available:
1. Open `examples/test_viz_layout.ipynb`
2. Run the `complex_rag` cell
3. Visually confirm:
   - Edges do NOT cross over nodes
   - Edges route around blocking nodes
   - Collapsed pipelines have edges connecting to their boundary
   - Expanded pipelines have edges routing to inner nodes

If the notebook is not convenient, create a quick Python script to render a nested graph:
```python
from hypergraph import Graph, node, SyncRunner
from hypergraph.viz import render_graph

@node(output_name="a")
def step_a(x): return x

@node(output_name="b")
def step_b(a): return a

@node(output_name="c")
def step_c(b): return b

inner = Graph(nodes=[step_b, step_c], name="inner")
outer = Graph(nodes=[step_a, inner.as_node()], name="outer")

# Render at depth=1 to see inner nodes
render_graph(outer, depth=1)
```

Verify the rendered output shows edges correctly routing to inner nodes without crossing the parent boundary or other nodes.
  </action>
  <verify>
1. `uv run pytest tests/viz/test_renderer.py -v` - All tests pass
2. Visual inspection of nested graph rendering shows correct edge routing
  </verify>
  <done>
All viz tests pass and visual inspection confirms edges route correctly around nodes at all nesting depths.
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `grep -n "i <= target.row" src/hypergraph/viz/assets/constraint-layout.js` shows inclusive check
2. `grep -n "node === target" src/hypergraph/viz/assets/constraint-layout.js` shows skip logic
3. `grep -n "_sourceAbsPos" src/hypergraph/viz/assets/layout.js` shows absolute position tracking
4. All viz tests pass
5. Visual inspection confirms no edges crossing nodes
</verification>

<success_criteria>
- EDGE-01: Edges route around nodes (no edges through nodes in any test case)
- EDGE-02: Collapsed nested graphs have edges flush to boundary
- EDGE-03: Double-nested graphs route edges to correct inner nodes
- EDGE-04: Same algorithm handles depth=0, depth=1, depth=2+ without special cases
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-fix-edge-routing/03-02-SUMMARY.md`
</output>
