---
phase: 02-type-compatibility-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hypergraph/_typing.py
  - tests/test_typing.py
autonomous: true

# Goal-backward verification
must_haves:
  truths:
    - "is_type_compatible(int, int) returns True"
    - "is_type_compatible(str, int) returns False"
    - "is_type_compatible(int, int | str) returns True"
    - "is_type_compatible(int | str, int | str | float) returns True"
    - "is_type_compatible(int | str, int) returns False"
    - "is_type_compatible(list[int], list[int]) returns True"
    - "is_type_compatible(list[int], list[str]) returns False"
    - "Forward reference 'int' resolves and compares correctly"
  artifacts:
    - path: "src/hypergraph/_typing.py"
      provides: "Type compatibility checking utilities"
      exports: ["is_type_compatible", "NoAnnotation", "Unresolvable", "safe_get_type_hints"]
      min_lines: 100
    - path: "tests/test_typing.py"
      provides: "Tests for type compatibility"
      min_lines: 80
  key_links:
    - from: "is_type_compatible"
      to: "_resolve_type"
      via: "resolves forward references before comparison"
      pattern: "_resolve_type"
    - from: "is_type_compatible"
      to: "_handle_union_types"
      via: "delegates Union handling"
      pattern: "_handle_union_types"
    - from: "is_type_compatible"
      to: "_handle_generic_types"
      via: "delegates generic handling"
      pattern: "_handle_generic_types"
---

<objective>
Create the type compatibility engine that determines if two types are compatible.

Purpose: Enable strict type validation in Phase 3 by providing a robust `is_type_compatible()` function that handles Union types, generics, forward references, and graceful degradation for missing/unresolvable annotations.

Output: New `_typing.py` module with type compatibility utilities adapted from pipefunc's proven patterns.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-type-extraction-infrastructure/01-01-SUMMARY.md

# Reference implementation (pipefunc patterns to adapt):
@tmp/pipefunc_typing.py
@tmp/type_validation_plan.md

# Existing codebase patterns:
@src/hypergraph/nodes/function.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create _typing.py with core types and forward ref resolution</name>
  <files>src/hypergraph/_typing.py</files>
  <action>
Create new module `src/hypergraph/_typing.py` with:

1. **Marker classes:**
   - `NoAnnotation` - marker for missing type annotations (allows check to be skipped)
   - `Unresolvable` - wrapper for unresolvable type hints (stores original string, warns on comparison)

2. **TypeCheckMemo NamedTuple:**
   - Store globals/locals for forward reference evaluation
   - Pattern from pipefunc but simplified (no self_type needed)

3. **Forward reference resolution:**
   - `_resolve_type(type_, memo)` - recursively resolves forward refs
   - Handle string annotations by converting to ForwardRef
   - Handle ForwardRef using `_evaluate` with version-aware signature (3.12 vs 3.13+)
   - Recursively resolve args of Union and generic types

4. **safe_get_type_hints(func):**
   - Wrapper around `get_type_hints()` that catches failures
   - Returns `Unresolvable` wrapper for hints that can't be resolved
   - Used by Phase 1's annotation properties (optional enhancement)

**Key simplifications vs pipefunc:**
- Remove numpy Array/ArrayElementType handling (not needed)
- Keep standard library only (no numpy dependency)
- Focus on Python 3.10+ (our minimum)

**Reference:** `tmp/pipefunc_typing.py` lines 24-78, 280-320
  </action>
  <verify>
```bash
cd /Users/giladrubin/python_workspace/hypergraph && uv run python -c "from hypergraph._typing import NoAnnotation, Unresolvable, TypeCheckMemo, safe_get_type_hints; print('imports ok')"
```
  </verify>
  <done>Module imports successfully with NoAnnotation, Unresolvable, TypeCheckMemo, safe_get_type_hints exported</done>
</task>

<task type="auto">
  <name>Task 2: Implement is_type_compatible with Union and generic handling</name>
  <files>src/hypergraph/_typing.py</files>
  <action>
Add the core type compatibility function and its helpers:

1. **`_check_identical_or_any(incoming, required)`:**
   - Return True if types are identical
   - Return True if required is `Any`
   - Return True if either is `NoAnnotation` (skip check)
   - Warn and return True if either is `Unresolvable`

2. **`_handle_union_types(incoming, required, memo)`:**
   - Both Union: all incoming members must be compatible with at least one required member
   - Incoming Union only: all incoming members must be compatible with required
   - Required Union only: incoming must be compatible with at least one required member
   - Return None if neither is Union (let other handlers try)
   - Support both `Union[a, b]` and `a | b` syntax (UnionType)

3. **`_handle_generic_types(incoming, required, memo)`:**
   - Compare origins (e.g., `list` == `list`)
   - Recursively compare type arguments (e.g., `int` vs `str`)
   - Handle Annotated by stripping metadata and comparing primary type
   - Return None if not both generic

4. **`_is_typevar_compatible(incoming, required, memo)`:**
   - If required is TypeVar, check against constraints/bound
   - Return None if required is not TypeVar

5. **`is_type_compatible(incoming, required, memo=None)`:**
   - Main entry point
   - Resolve forward refs first
   - Check identical/Any
   - Check TypeVar
   - Check Union
   - Check generic
   - Return False if none match

**Reference:** `tmp/pipefunc_typing.py` lines 81-259

**Important:** Handle `types.UnionType` for Python 3.10+ `|` syntax in addition to `typing.Union`.
  </action>
  <verify>
```bash
cd /Users/giladrubin/python_workspace/hypergraph && uv run python -c "
from hypergraph._typing import is_type_compatible
# Basic tests
assert is_type_compatible(int, int) == True
assert is_type_compatible(str, int) == False
assert is_type_compatible(int, int | str) == True
assert is_type_compatible(int | str, int) == False
print('basic tests pass')
"
```
  </verify>
  <done>is_type_compatible handles simple types, Union types (both Union and | syntax), and returns correct True/False</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for type compatibility</name>
  <files>tests/test_typing.py</files>
  <action>
Create test file `tests/test_typing.py` with comprehensive tests:

1. **Simple type compatibility:**
   - `int` vs `int` → True
   - `str` vs `int` → False
   - `int` vs `Any` → True
   - `NoAnnotation` vs anything → True (skip check)

2. **Union type compatibility:**
   - `int` vs `int | str` → True (int satisfies Union containing int)
   - `int | str` vs `int | str | float` → True (all members of incoming in required)
   - `int | str` vs `int` → False (str doesn't satisfy int)
   - `int | str` vs `int | str` → True (exact match)
   - Both `Union[a, b]` and `a | b` syntax

3. **Generic type compatibility:**
   - `list[int]` vs `list[int]` → True
   - `list[int]` vs `list[str]` → False
   - `list[int]` vs `list` → True (unparameterized accepts any)
   - `dict[str, int]` vs `dict[str, int]` → True
   - `dict[str, int]` vs `dict[str, str]` → False

4. **Forward reference resolution:**
   - String `'int'` resolves to `int`
   - ForwardRef to class defined in same module

5. **Graceful degradation:**
   - `Unresolvable` warns but returns True (skip check)
   - Test with invalid forward ref string

6. **Edge cases:**
   - `None` type (type(None))
   - TypeVar with constraints
   - Nested generics: `list[dict[str, int]]`

**Pattern:** Use pytest with descriptive test names.
  </action>
  <verify>
```bash
cd /Users/giladrubin/python_workspace/hypergraph && uv run pytest tests/test_typing.py -v
```
  </verify>
  <done>All tests pass, covering simple types, Union, generics, forward refs, and edge cases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run python -c "from hypergraph._typing import is_type_compatible, NoAnnotation, Unresolvable"` succeeds
- [ ] `uv run pytest tests/test_typing.py -v` passes all tests
- [ ] `uv run pytest tests/ -v` passes all existing tests (no regressions)
- [ ] Type compatibility handles Union, generics, forward refs per success criteria
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- is_type_compatible correctly handles:
  - Simple types (int, str)
  - Union types (both Union and | syntax)
  - Generic types (list[int], dict[str, int])
  - Forward references
- Graceful degradation for missing/unresolvable annotations
  </success_criteria>

<output>
After completion, create `.planning/phases/02-type-compatibility-engine/02-01-SUMMARY.md`
</output>
