---
phase: 02-unify-edge-routing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hypergraph/viz/assets/layout.js
  - src/hypergraph/viz/assets/state_utils.js
autonomous: true

must_haves:
  truths:
    - "JavaScript can build hierarchy tree from flat node list"
    - "JavaScript can resolve logical edge target to visual target based on expansion state"
    - "Hierarchy building is O(n) using object references"
  artifacts:
    - path: "src/hypergraph/viz/assets/layout.js"
      provides: "buildHierarchy and resolveEdgeTargets functions"
      exports: ["buildHierarchy", "resolveEdgeTargets"]
    - path: "src/hypergraph/viz/assets/state_utils.js"
      provides: "findEntryNodes and findExitNodes helpers"
      exports: ["findEntryNodes", "findExitNodes"]
  key_links:
    - from: "layout.js:buildHierarchy"
      to: "flat nodes array"
      via: "nodeMap with parent references"
      pattern: "nodeMap\\.get\\(.*parentNode"
    - from: "layout.js:resolveEdgeTargets"
      to: "expansionState"
      via: "expansion check before recursion"
      pattern: "expansionState\\.get"
---

<objective>
Add hierarchy building and edge target resolution to JavaScript

Purpose: Enable JavaScript to own all edge routing decisions by understanding graph hierarchy
Output: New functions in layout.js that build hierarchy tree and resolve edge targets
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-unify-edge-routing/02-RESEARCH.md

# Phase 1 summaries - foundation abstractions complete
@.planning/phases/01-core-abstractions/01-01-SUMMARY.md
@.planning/phases/01-core-abstractions/01-02-SUMMARY.md

# Current implementation files
@src/hypergraph/viz/assets/layout.js
@src/hypergraph/viz/assets/state_utils.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add buildHierarchy function to layout.js</name>
  <files>src/hypergraph/viz/assets/layout.js</files>
  <action>
Add a `buildHierarchy(flatNodes)` function to layout.js that converts a flat node array (with parentNode references) into a hierarchical tree structure.

Implementation based on research Pattern 1:
1. Create a Map (nodeMap) from node ID to node object with empty children array
2. Iterate through nodes, using object references to build parent-child relationships
3. Return { nodeMap, roots } where roots are nodes with no parent

Key requirements:
- O(n) time complexity using object references (not recursion)
- Include cycle detection (track visited IDs)
- Handle missing parents gracefully (warn but don't crash)
- Each node in nodeMap should have: id, data, parentNode, children[], _original

Export the function in the return block of the IIFE.

Example structure:
```javascript
function buildHierarchy(flatNodes) {
  var nodeMap = new Map();
  var roots = [];

  // Phase 1: Create node objects with empty children
  flatNodes.forEach(function(node) {
    nodeMap.set(node.id, {
      id: node.id,
      data: node.data,
      parentNode: node.parentNode,
      children: [],
      _original: node
    });
  });

  // Phase 2: Build relationships using object references
  flatNodes.forEach(function(node) {
    var nodeObj = nodeMap.get(node.id);
    if (node.parentNode) {
      var parent = nodeMap.get(node.parentNode);
      if (parent) {
        parent.children.push(nodeObj);
      }
    } else {
      roots.push(nodeObj);
    }
  });

  return { nodeMap: nodeMap, roots: roots };
}
```
  </action>
  <verify>
Open browser console, run:
```javascript
var testNodes = [
  {id: 'a', data: {nodeType: 'PIPELINE'}},
  {id: 'b', parentNode: 'a', data: {nodeType: 'FUNCTION'}},
  {id: 'c', parentNode: 'a', data: {nodeType: 'FUNCTION'}}
];
var h = HypergraphVizLayout.buildHierarchy(testNodes);
console.log(h.roots.length === 1);  // true
console.log(h.nodeMap.get('a').children.length === 2);  // true
```
  </verify>
  <done>buildHierarchy function exists, builds hierarchy in O(n), handles cycles gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Add entry/exit node helpers to state_utils.js</name>
  <files>src/hypergraph/viz/assets/state_utils.js</files>
  <action>
Add helper functions to identify entry and exit nodes within a container.

Entry nodes: Child nodes with no incoming edges from siblings (first in topological order)
Exit nodes: Child nodes with no outgoing edges to siblings (last in topological order)

For simplicity, use positional heuristic based on the existing layout:
- Entry node: First child in the children array (sorted by position)
- Exit node: Last child in the children array (sorted by position)

Add two functions:
```javascript
/**
 * Find entry nodes for a container (nodes where edges should enter)
 * @param {Array} children - Child nodes of the container
 * @param {Array} edges - All edges in the graph
 * @returns {Array} Entry node IDs
 */
function findEntryNodes(children, edges) {
  if (!children || children.length === 0) return [];

  // Build set of nodes that receive edges from siblings
  var childIds = new Set(children.map(function(c) { return c.id; }));
  var hasIncoming = new Set();

  edges.forEach(function(e) {
    if (childIds.has(e.source) && childIds.has(e.target)) {
      hasIncoming.add(e.target);
    }
  });

  // Entry nodes have no incoming edges from siblings
  var entryNodes = children.filter(function(c) {
    return !hasIncoming.has(c.id);
  });

  // Fallback: if all have incoming (cycle), use first child
  return entryNodes.length > 0 ? entryNodes : [children[0]];
}

/**
 * Find exit nodes for a container (nodes where edges should exit)
 * @param {Array} children - Child nodes of the container
 * @param {Array} edges - All edges in the graph
 * @returns {Array} Exit node IDs
 */
function findExitNodes(children, edges) {
  if (!children || children.length === 0) return [];

  var childIds = new Set(children.map(function(c) { return c.id; }));
  var hasOutgoing = new Set();

  edges.forEach(function(e) {
    if (childIds.has(e.source) && childIds.has(e.target)) {
      hasOutgoing.add(e.source);
    }
  });

  var exitNodes = children.filter(function(c) {
    return !hasOutgoing.has(c.id);
  });

  return exitNodes.length > 0 ? exitNodes : [children[children.length - 1]];
}
```

Export both functions in the return block.
  </action>
  <verify>
In browser console:
```javascript
var children = [{id: 'b'}, {id: 'c'}];
var edges = [{source: 'b', target: 'c'}];
console.log(HypergraphVizState.findEntryNodes(children, edges)[0].id === 'b');  // true
console.log(HypergraphVizState.findExitNodes(children, edges)[0].id === 'c');  // true
```
  </verify>
  <done>findEntryNodes and findExitNodes exported from state_utils.js</done>
</task>

<task type="auto">
  <name>Task 3: Add resolveEdgeTargets function to layout.js</name>
  <files>src/hypergraph/viz/assets/layout.js</files>
  <action>
Add a `resolveEdgeTargets(edge, expansionState, hierarchy, edges)` function that resolves logical source/target IDs to visual IDs based on expansion state.

When a container is collapsed, edges should connect to the container.
When a container is expanded, edges should connect to entry/exit nodes inside.

Implementation based on research Pattern 2:
```javascript
/**
 * Resolve edge endpoints from logical to visual based on expansion state
 * @param {Object} edge - Edge with source and target IDs
 * @param {Map} expansionState - Which nodes are expanded
 * @param {Object} hierarchy - Result of buildHierarchy()
 * @param {Array} allEdges - All edges for entry/exit calculation
 * @returns {Object} { visualSource, visualTarget, logicalSource, logicalTarget }
 */
function resolveEdgeTargets(edge, expansionState, hierarchy, allEdges) {
  var VizState = root.HypergraphVizState;
  var maxDepth = 10;  // Prevent infinite recursion

  var resolveTarget = function(logicalId, depth) {
    if (depth <= 0) return logicalId;

    var node = hierarchy.nodeMap.get(logicalId);
    if (!node) return logicalId;

    // Not a pipeline OR not expanded -> use logical ID
    var isPipeline = node.data && node.data.nodeType === 'PIPELINE';
    var isExpanded = expansionState.get(logicalId);

    if (!isPipeline || !isExpanded) {
      return logicalId;
    }

    // Expanded container -> find entry nodes
    if (!node.children || node.children.length === 0) {
      return logicalId;  // Empty container
    }

    var entryNodes = VizState.findEntryNodes(node.children, allEdges);
    if (entryNodes.length === 0) return logicalId;

    // Recurse into first entry node
    return resolveTarget(entryNodes[0].id, depth - 1);
  };

  var resolveSource = function(logicalId, depth) {
    if (depth <= 0) return logicalId;

    var node = hierarchy.nodeMap.get(logicalId);
    if (!node) return logicalId;

    var isPipeline = node.data && node.data.nodeType === 'PIPELINE';
    var isExpanded = expansionState.get(logicalId);

    if (!isPipeline || !isExpanded) {
      return logicalId;
    }

    if (!node.children || node.children.length === 0) {
      return logicalId;
    }

    var exitNodes = VizState.findExitNodes(node.children, allEdges);
    if (exitNodes.length === 0) return logicalId;

    return resolveSource(exitNodes[0].id, depth - 1);
  };

  return {
    visualSource: resolveSource(edge.source, maxDepth),
    visualTarget: resolveTarget(edge.target, maxDepth),
    logicalSource: edge.source,
    logicalTarget: edge.target
  };
}
```

Export the function.

Note: This function is not yet integrated with rendering - that's Plan 02.
  </action>
  <verify>
Test in browser with mock data:
```javascript
// Setup: Pipeline 'p' is expanded, contains 'a' and 'b'
var nodes = [
  {id: 'p', data: {nodeType: 'PIPELINE'}},
  {id: 'a', parentNode: 'p', data: {nodeType: 'FUNCTION'}},
  {id: 'b', parentNode: 'p', data: {nodeType: 'FUNCTION'}},
  {id: 'ext', data: {nodeType: 'FUNCTION'}}
];
var edges = [{source: 'a', target: 'b'}];
var hierarchy = HypergraphVizLayout.buildHierarchy(nodes);
var expansionState = new Map([['p', true]]);

// Edge from external to pipeline should resolve to entry node
var result = HypergraphVizLayout.resolveEdgeTargets(
  {source: 'ext', target: 'p'},
  expansionState,
  hierarchy,
  edges
);
console.log(result.visualTarget === 'a');  // true - resolves to entry node
console.log(result.logicalTarget === 'p');  // true - preserves logical
```
  </verify>
  <done>resolveEdgeTargets function exists and correctly resolves logical to visual IDs</done>
</task>

</tasks>

<verification>
All functions exist and are exported:
- `HypergraphVizLayout.buildHierarchy`
- `HypergraphVizLayout.resolveEdgeTargets`
- `HypergraphVizState.findEntryNodes`
- `HypergraphVizState.findExitNodes`

Run existing viz tests to ensure no regressions:
```bash
uv run pytest tests/viz/ -v
```
</verification>

<success_criteria>
1. buildHierarchy builds tree from flat nodes in O(n) time
2. findEntryNodes/findExitNodes identify correct nodes topologically
3. resolveEdgeTargets resolves pipeline containers to inner nodes when expanded
4. All existing viz tests pass
5. No runtime errors when viewing existing visualizations
</success_criteria>

<output>
After completion, create `.planning/phases/02-unify-edge-routing/02-01-SUMMARY.md`
</output>
