---
phase: 02-unify-edge-routing
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/hypergraph/viz/assets/layout.js
  - src/hypergraph/viz/assets/app.js
autonomous: true

must_haves:
  truths:
    - "Edges connect to visual targets based on expansion state"
    - "Expand/collapse works dynamically without Python re-render"
    - "Edge routing logic exists in ONE place (JavaScript)"
  artifacts:
    - path: "src/hypergraph/viz/assets/layout.js"
      provides: "useLayout that applies edge resolution"
      contains: "resolveEdgeTargets"
    - path: "src/hypergraph/viz/assets/app.js"
      provides: "Integration of edge resolution with rendering"
      contains: "visualSource"
  key_links:
    - from: "layout.js:performRecursiveLayout"
      to: "resolveEdgeTargets"
      via: "edge processing loop"
      pattern: "resolveEdgeTargets\\("
    - from: "app.js"
      to: "layout.js:useLayout"
      via: "hook call with edges"
      pattern: "useLayout\\(.*edges"
---

<objective>
Integrate edge resolution with rendering and verify dynamic expand/collapse

Purpose: Complete the unification of edge routing logic in JavaScript
Output: Working edge routing that responds dynamically to expansion state changes
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-unify-edge-routing/02-RESEARCH.md

# Dependency: Plan 01 must be complete
@.planning/phases/02-unify-edge-routing/02-01-SUMMARY.md

# Implementation files
@src/hypergraph/viz/assets/layout.js
@src/hypergraph/viz/assets/app.js
@src/hypergraph/viz/assets/state_utils.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate edge resolution into performRecursiveLayout</name>
  <files>src/hypergraph/viz/assets/layout.js</files>
  <action>
Update the `performRecursiveLayout` function to use `resolveEdgeTargets` when processing edges.

Currently, `performRecursiveLayout` processes edges as-is without resolving targets. We need to:
1. Build hierarchy at the start of layout
2. For edges that cross container boundaries (source or target is expanded pipeline), resolve to visual targets
3. Store both logical and visual IDs in edge data for debugging

Key changes to `performRecursiveLayout`:

1. At the start, call buildHierarchy:
```javascript
var hierarchy = buildHierarchy(visibleNodes);
```

2. When filtering edges for a container, use logical IDs but track visual resolution:
```javascript
// After root layout, resolve cross-container edges
// These are edges where source or target is a pipeline
rootResult.edges.forEach(function(e) {
  var resolved = resolveEdgeTargets(e._original, expansionState, hierarchy, edges);
  // Store resolved info for rendering
  e._original.data = e._original.data || {};
  e._original.data.visualSource = resolved.visualSource;
  e._original.data.visualTarget = resolved.visualTarget;
});
```

3. Similarly for child layout results, resolve edge targets.

The key insight is: the constraint layout operates on node positions, but when rendering edges, we may need to render them to different visual targets than the logical targets.

For this phase, focus on storing the resolved visual targets in edge data. The actual re-routing happens in constraint-layout.js which already routes based on source/target positions.

If source or target is not the same as visual source/target, the edge needs special handling:
- Either re-route the edge to the visual target's position
- Or mark the edge for later processing

Simpler approach for now: After layout, adjust edge endpoints in `allPositionedEdges` when visual differs from logical.
  </action>
  <verify>
Render a nested graph visualization (e.g., from test_viz_layout), expand a pipeline, and verify in browser console:
```javascript
// Check edge data has visual resolution info
__hypergraphVizLayout.edges.forEach(e => {
  if (e.data && e.data.visualTarget) {
    console.log(e.id, 'logical:', e.target, 'visual:', e.data.visualTarget);
  }
});
```
  </verify>
  <done>performRecursiveLayout stores visual source/target in edge data</done>
</task>

<task type="auto">
  <name>Task 2: Update useLayout to pass expansion state to edge resolution</name>
  <files>src/hypergraph/viz/assets/layout.js</files>
  <action>
Ensure the `useLayout` hook properly passes expansion state through to `performRecursiveLayout` for edge resolution.

Current flow:
1. `useLayout(nodes, edges, expansionState)` receives expansion state
2. Calls `performRecursiveLayout(visibleNodes, edges, expansionState, debugMode)`
3. Inside, should now also build hierarchy and resolve edges

Verify the expansion state is being used:
1. In `performRecursiveLayout`, after calling `buildHierarchy`, iterate through all edges
2. For each edge, check if source or target is an expanded pipeline
3. If so, resolve to visual targets
4. Update the edge's _original.data with resolution info

Add a helper function `resolveAllEdgeTargets`:
```javascript
function resolveAllEdgeTargets(edges, expansionState, hierarchy) {
  return edges.map(function(edge) {
    var resolved = resolveEdgeTargets(
      edge._original || edge,
      expansionState,
      hierarchy,
      edges.map(function(e) { return e._original || e; })
    );

    return {
      ...edge,
      _resolvedSource: resolved.visualSource,
      _resolvedTarget: resolved.visualTarget
    };
  });
}
```

Call this after layout is complete but before returning edges.
  </action>
  <verify>
In browser, expand/collapse a pipeline and check that:
1. Edges update when pipeline is expanded (may connect to inner nodes)
2. Edges update when pipeline is collapsed (connect to pipeline boundary)
3. No JavaScript errors in console
  </verify>
  <done>useLayout correctly passes expansion state and resolves edge targets</done>
</task>

<task type="auto">
  <name>Task 3: Add test case for dynamic expand/collapse edge resolution</name>
  <files>tests/viz/test_renderer.py</files>
  <action>
Add a test that verifies edge resolution changes based on expansion state.

Create a new test function `test_edge_resolution_with_expansion`:

```python
def test_edge_resolution_with_expansion():
    """Edge targets should resolve based on expansion state."""
    # Create a graph with nested pipeline
    @node(output_name="x")
    def outer_input(a: int) -> int:
        return a

    @node(output_name="y")
    def inner_step(x: int) -> int:
        return x * 2

    inner = Graph(nodes=[inner_step], name="inner_pipeline")

    @node(output_name="result")
    def outer_output(y: int) -> int:
        return y

    outer = Graph(nodes=[outer_input, inner.as_node(), outer_output])

    # Render with depth=0 (collapsed)
    viz_graph = outer.to_viz_graph()
    result_collapsed = render_graph(viz_graph, depth=0)

    # Render with depth=1 (expanded)
    result_expanded = render_graph(viz_graph, depth=1)

    # Find edges targeting the inner pipeline
    def find_edge_to_inner(edges):
        return [e for e in edges if 'inner_pipeline' in e['target']]

    # In collapsed state, edge should target the pipeline node
    collapsed_edges = find_edge_to_inner(result_collapsed['edges'])
    # In expanded state, edge may have different visual target (handled by JS)
    expanded_edges = find_edge_to_inner(result_expanded['edges'])

    # Both should have edges - the logical target is the same
    # Visual resolution happens in JavaScript at render time
    assert len(collapsed_edges) > 0 or len(expanded_edges) > 0
```

The key point: Python provides logical IDs, JavaScript resolves to visual IDs.
This test verifies the Python side produces correct logical edges regardless of depth.
  </action>
  <verify>
```bash
uv run pytest tests/viz/test_renderer.py::test_edge_resolution_with_expansion -v
```
  </verify>
  <done>Test exists and passes, validating edge resolution behavior</done>
</task>

</tasks>

<verification>
1. All viz tests pass:
```bash
uv run pytest tests/viz/ -v
```

2. Manual verification in browser:
   - Open a visualization with nested graphs
   - Expand a pipeline node
   - Verify edges connect to inner nodes (not pipeline boundary)
   - Collapse the pipeline
   - Verify edges connect to pipeline boundary

3. Console check:
```javascript
// Should show no errors
console.log(window.__hypergraphVizLayout);
```
</verification>

<success_criteria>
1. Edge routing logic exists in ONE place (JavaScript)
2. Python renderer doesn't compute innerTargets (just provides graph structure)
3. Dynamic expand/collapse works without re-rendering from Python
4. Edges connect to correct visual targets based on expansion state
5. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-unify-edge-routing/02-02-SUMMARY.md`
</output>
