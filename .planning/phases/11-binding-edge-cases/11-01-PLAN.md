---
phase: 11-binding-edge-cases
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [tests/test_bind_edge_cases.py]
autonomous: true

must_haves:
  truths:
    - "bind(x=None) correctly binds None as a value, making param optional"
    - "bind() with multiple values at once applies all bindings correctly"
    - "bind() on a cycle seed parameter does not change seed status"
    - "unbind() restores parameter to original required/optional status based on function defaults"
  artifacts:
    - path: "tests/test_bind_edge_cases.py"
      provides: "Binding edge case tests"
      contains: "class TestBindNone"
  key_links:
    - from: "tests/test_bind_edge_cases.py"
      to: "src/hypergraph/graph.py"
      via: "test methods calling Graph.bind, Graph.unbind"
      pattern: "\\.bind\\(|\\.unbind\\("
---

<objective>
Test bind/unbind edge cases to verify correct handling of None values, multiple bindings, cycle seed interactions, and unbind restoration behavior.

Purpose: Ensure the binding system handles edge cases correctly, particularly distinguishing between "no value" and "None as a value", and properly categorizing parameters after bind/unbind operations.

Output: New test file `tests/test_bind_edge_cases.py` with comprehensive tests for all 4 BIND requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

Source files:
@src/hypergraph/graph.py (bind, unbind, _categorize_param methods)
@tests/test_graph.py (existing bind tests in TestGraphBind class for reference patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_bind_edge_cases.py with BIND-01 and BIND-02 tests</name>
  <files>tests/test_bind_edge_cases.py</files>
  <action>
Create new test file `tests/test_bind_edge_cases.py` with tests for binding edge cases.

**File structure:**
```python
"""Tests for bind/unbind edge cases."""

import pytest
from hypergraph.graph import Graph
from hypergraph.nodes.function import node
```

**BIND-01: bind(x=None) correctly binds None as a value**

Create class `TestBindNone`:

1. **test_bind_none_makes_param_optional** - Verify bind(x=None) moves param to optional
   - Create graph with `def foo(x: int) -> int: return x or 0`
   - Before bind: x is in required
   - After `g.bind(x=None)`: x is in optional, not required
   - Assert `g2.inputs.bound == {"x": None}` (None is the actual value)

2. **test_bind_none_preserved_in_bound_dict** - Verify None is stored correctly
   - Create graph, bind x=None
   - Assert `g2.inputs.bound["x"] is None` (None preserved, not removed)

3. **test_bind_none_vs_unbind** - Verify bind(x=None) is NOT the same as unbind
   - Create graph, bind x=10, then bind x=None
   - Assert x is still optional (has binding)
   - Assert binding value is None
   - This is different from unbind("x") which would remove the binding

4. **test_bind_none_multiple_params** - Bind multiple params where some are None
   - `g.bind(x=None, y=10, z=None)`
   - All three should be in optional
   - Bound dict should have all three with correct values

**BIND-02: bind() with multiple values at once**

Create class `TestBindMultiple`:

5. **test_bind_multiple_all_become_optional** - All bound params move to optional
   - Create graph with `def foo(a, b, c, d): ...` (all required)
   - `g.bind(a=1, b=2, c=3)` in single call
   - Assert a, b, c are in optional
   - Assert d remains in required
   - Assert bound dict has all three values

6. **test_bind_multiple_preserves_existing_bindings** - Multiple bind preserves prior
   - `g.bind(a=1)` then `g2.bind(b=2, c=3)` (chained)
   - Final bound dict should have a, b, c

7. **test_bind_multiple_override_partial** - Override some keys, add others
   - `g.bind(a=1, b=2)` then `g2.bind(b=20, c=3)`
   - Final: a=1, b=20, c=3

8. **test_bind_multiple_empty_call** - `bind()` with no args is valid no-op
   - `g.bind()` should return new graph with no changes
   - Bound dict unchanged
  </action>
  <verify>uv run pytest tests/test_bind_edge_cases.py -v</verify>
  <done>
- test_bind_edge_cases.py exists with TestBindNone and TestBindMultiple classes
- 8 tests covering BIND-01 and BIND-02
- All tests pass (verifying current implementation handles these cases)
- No syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add BIND-03 and BIND-04 tests</name>
  <files>tests/test_bind_edge_cases.py</files>
  <action>
Add tests for cycle seed interaction and unbind restoration.

**BIND-03: bind() interaction with cycle seeds**

Create class `TestBindCycleSeeds`:

9. **test_bind_seed_param_remains_seed** - Binding a seed doesn't change its category
   - Create cyclic graph: `@node(output_name="count") def counter(count): return count + 1`
   - This creates a seed "count" (self-loop cycle)
   - Try to bind: `g.bind(count=0)`
   - The bind should be REJECTED because 'count' is edge-produced
   - Assert raises ValueError with message about output of node

10. **test_seed_not_bindable_multi_node_cycle** - Multi-node cycle seed also not bindable
    - Create A -> B -> A cycle (B consumes A's output, A consumes B's output)
    - The cycle parameter is a seed
    - Attempting to bind it should raise ValueError

11. **test_non_seed_edge_produced_not_bindable** - Regular edge values also not bindable
    - Linear graph: A produces x, B consumes x
    - `g.bind(x=10)` should raise ValueError (x is output of A)

**BIND-04: unbind() restores correct required vs optional status**

Create class `TestUnbindRestoresStatus`:

12. **test_unbind_restores_required** - Param without default returns to required
    - Create graph with `def foo(x, y): ...` (both required)
    - Bind x=10, now x is optional
    - Unbind x, x returns to required (no default in function)

13. **test_unbind_restores_optional_with_default** - Param with default stays optional
    - Create graph with `def foo(x, y=10): ...` (y has default)
    - Bind y=20 (overrides default)
    - Unbind y, y is still optional (has function default)
    - But y is NOT in bound dict anymore

14. **test_unbind_multiple_mixed** - Unbind multiple params with different statuses
    - `def foo(a, b=1, c, d=2): ...`
    - Bind all four
    - Unbind a and b
    - a returns to required (no default)
    - b returns to optional (has default 1)
    - c and d remain in optional (still bound)

15. **test_unbind_preserves_other_bindings** - Unbind is selective
    - Bind a, b, c
    - Unbind only b
    - a and c remain bound

16. **test_unbind_chained** - Multiple unbind calls work correctly
    - Bind a, b, c
    - `g.unbind("a").unbind("b")` chained
    - Only c remains bound
  </action>
  <verify>uv run pytest tests/test_bind_edge_cases.py -v</verify>
  <done>
- TestBindCycleSeeds and TestUnbindRestoresStatus classes added
- 8 additional tests covering BIND-03 and BIND-04
- All tests pass
- Total: 16 tests covering all 4 BIND requirements
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/test_bind_edge_cases.py -v` runs all tests
- [ ] All 16 tests pass
- [ ] No syntax errors in test file
- [ ] Test classes follow existing patterns from test_graph.py (docstrings, @node decorator)
- [ ] Tests cover all 4 BIND requirements
</verification>

<success_criteria>
- tests/test_bind_edge_cases.py exists with 4 test classes
- 16 tests total covering BIND-01 through BIND-04
- bind(x=None) correctly binds None (not treated as unbind)
- bind() with multiple values applies all bindings
- bind() on edge-produced values (including seeds) raises ValueError
- unbind() restores params to correct required/optional based on function defaults
- All tests pass, verifying current implementation handles edge cases correctly
</success_criteria>

<output>
After completion, create `.planning/phases/11-binding-edge-cases/11-01-SUMMARY.md`
</output>
