---
phase: 01-type-extraction-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/hypergraph/nodes/function.py, src/hypergraph/nodes/graph_node.py, src/hypergraph/graph.py]
autonomous: true

must_haves:
  truths:
    - "Graph can be constructed with strict_types=True parameter"
    - "FunctionNode exposes parameter types via parameter_annotations property"
    - "FunctionNode exposes return type via output_annotation property"
    - "GraphNode exposes its output node's return type via output_annotation property"
  artifacts:
    - path: "src/hypergraph/nodes/function.py"
      provides: "parameter_annotations and output_annotation properties"
      contains: "def parameter_annotations"
    - path: "src/hypergraph/nodes/graph_node.py"
      provides: "output_annotation property delegating to inner graph"
      contains: "def output_annotation"
    - path: "src/hypergraph/graph.py"
      provides: "strict_types parameter on Graph constructor"
      contains: "strict_types"
  key_links:
    - from: "FunctionNode.parameter_annotations"
      to: "get_type_hints"
      via: "uses get_type_hints from typing module"
      pattern: "get_type_hints"
    - from: "GraphNode.output_annotation"
      to: "Graph.leaf_nodes"
      via: "finds output node and gets its return annotation"
      pattern: "output_annotation"
---

<objective>
Add type extraction infrastructure to hypergraph nodes and Graph constructor.

Purpose: Enable nodes to expose their type information so later phases can validate type compatibility between connected nodes.
Output: FunctionNode with parameter_annotations and output_annotation properties, GraphNode with output_annotation property, Graph with strict_types parameter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/hypergraph/nodes/function.py
@src/hypergraph/nodes/graph_node.py
@src/hypergraph/graph.py
@tmp/type_validation_plan.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type annotation properties to FunctionNode</name>
  <files>src/hypergraph/nodes/function.py</files>
  <action>
    Add two new properties to FunctionNode:

    1. `parameter_annotations` property:
       - Returns `dict[str, Any]` mapping parameter names to their type annotations
       - Use `get_type_hints(self.func)` to extract annotations
       - Handle errors gracefully (return empty dict if get_type_hints fails)
       - Exclude 'return' key from the result
       - Use renamed input names (from self.inputs), not original parameter names

    2. `output_annotation` property:
       - Returns `dict[str, Any]` mapping output names to their type annotations
       - For single output: map output_name to return type annotation
       - For multiple outputs with tuple return: map each output to corresponding tuple element type
       - For no outputs (side-effect node): return empty dict
       - Handle missing return annotation gracefully (return empty dict)

    Pattern to follow: Existing `defaults` property shows how to access function metadata.

    Use `typing.get_type_hints()` which is already imported in the file.
    Handle edge cases:
    - Forward references that fail to resolve → return empty dict
    - No annotations on function → return empty dict
    - Partial annotations (some params annotated, others not) → include only annotated ones
  </action>
  <verify>
    ```python
    from hypergraph import node
    @node(output_name="result")
    def typed_func(x: int, y: str) -> float: return 0.0
    assert typed_func.parameter_annotations == {"x": int, "y": str}
    assert typed_func.output_annotation == {"result": float}
    ```
  </verify>
  <done>
    - FunctionNode.parameter_annotations returns dict of param → type
    - FunctionNode.output_annotation returns dict of output → type
    - Both handle missing/failed annotations gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add output_annotation property to GraphNode</name>
  <files>src/hypergraph/nodes/graph_node.py</files>
  <action>
    Add `output_annotation` property to GraphNode:

    - Returns `dict[str, Any]` mapping output names to their type annotations
    - For each output name in self.outputs, find the node in self._graph that produces it
    - If that node has `output_annotation` property, get the type for that output
    - Aggregate into a dict: {output_name: type, ...}

    Implementation approach:
    1. Build a mapping: output_name → source_node_name (can iterate self._graph._nodes)
    2. For each output in self.outputs:
       - Find the node that produces it
       - If node has output_annotation attribute, get the type
       - Otherwise skip that output

    Note: This does NOT recursively validate the inner graph's types - it just exposes the output types for the outer graph to check. Inner graph validation (if any) happens when that inner graph is constructed with its own strict_types setting.
  </action>
  <verify>
    ```python
    from hypergraph import node, Graph
    @node(output_name="x")
    def inner_func(a: int) -> str: return "hello"
    inner_graph = Graph([inner_func], name="inner")
    gn = inner_graph.as_node()
    assert gn.output_annotation == {"x": str}
    ```
  </verify>
  <done>
    - GraphNode.output_annotation returns dict of output → type
    - Types come from the inner graph's nodes that produce each output
    - Missing annotations handled gracefully
  </done>
</task>

<task type="auto">
  <name>Task 3: Add strict_types parameter to Graph constructor</name>
  <files>src/hypergraph/graph.py</files>
  <action>
    Add `strict_types` parameter to Graph.__init__:

    1. Add parameter: `strict_types: bool = False`
    2. Store as instance attribute: `self._strict_types = strict_types`
    3. Add read-only property: `strict_types` that returns self._strict_types

    DO NOT add validation logic yet - that's Phase 3 (TYPE-05, TYPE-06).
    This phase just adds the parameter and stores it.

    Also update the docstring to document the new parameter.

    Note: When copying graphs (bind/unbind), preserve the strict_types setting in _shallow_copy().
  </action>
  <verify>
    ```python
    from hypergraph import Graph, node
    @node(output_name="x")
    def f(): return 1
    g1 = Graph([f])
    assert g1.strict_types == False
    g2 = Graph([f], strict_types=True)
    assert g2.strict_types == True
    # Verify preserved through bind
    g3 = g2.bind(x=1)  # Will fail because x is output, but point is testing bind
    ```
  </verify>
  <done>
    - Graph accepts strict_types parameter (default False)
    - Graph.strict_types property returns the value
    - Value preserved through bind/unbind operations
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/` - all existing tests pass
- [ ] FunctionNode.parameter_annotations works with typed function
- [ ] FunctionNode.output_annotation works with typed function
- [ ] GraphNode.output_annotation works with nested graph
- [ ] Graph(strict_types=True) creates without error
- [ ] No TypeErrors or import errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- TYPE-01, TYPE-02, TYPE-03 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-type-extraction-infrastructure/01-01-SUMMARY.md`
</output>
