---
phase: 10-type-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [tests/test_typing.py]
autonomous: true

must_haves:
  truths:
    - "Literal types validated correctly (Literal['a', 'b'])"
    - "Protocol types validated correctly (structural typing)"
    - "TypedDict types validated correctly"
    - "NamedTuple types validated correctly"
    - "ParamSpec types handled correctly"
    - "Self type (Python 3.11+) handled correctly"
    - "Recursive types handled without infinite loop"
  artifacts:
    - path: "tests/test_typing.py"
      provides: "Advanced type compatibility tests"
      contains: "class TestLiteralTypeCompatibility"
  key_links:
    - from: "tests/test_typing.py"
      to: "src/hypergraph/_typing.py"
      via: "test methods calling is_type_compatible with advanced types"
      pattern: "is_type_compatible.*Literal|Protocol|TypedDict|NamedTuple"
---

<objective>
Test type validation handles advanced Python types correctly.

Purpose: Verify the type compatibility system handles Literal, Protocol, TypedDict, NamedTuple, ParamSpec, Self, and recursive types - either correctly validating them or gracefully degrading with appropriate warnings.

Output: New test classes in tests/test_typing.py covering all 7 TYPE requirements.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

Source files:
@src/hypergraph/_typing.py
@tests/test_typing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Literal type tests (TYPE-01)</name>
  <files>tests/test_typing.py</files>
  <action>
Add new test class `TestLiteralTypeCompatibility` after `TestEdgeCases` class.

**Import:** Add `Literal` to the existing imports from `typing`.

**Tests to create:**

1. **test_literal_identical_values_compatible** - Same Literal is compatible
   - `Literal["a", "b"]` is compatible with `Literal["a", "b"]`

2. **test_literal_subset_into_superset_compatible** - Subset values compatible with superset
   - `Literal["a"]` should be compatible with `Literal["a", "b"]`

3. **test_literal_superset_into_subset_not_compatible** - More values than accepted
   - `Literal["a", "b", "c"]` should NOT be compatible with `Literal["a", "b"]`

4. **test_literal_value_into_literal_compatible** - Value matches Literal
   - Note: At type level, we can't test runtime values, but test that Literal types compare

5. **test_literal_into_base_type_compatible** - Literal into its base type
   - `Literal["a"]` should be compatible with `str`
   - `Literal[1, 2]` should be compatible with `int`

6. **test_base_type_into_literal_not_compatible** - Base type has more values
   - `str` should NOT be compatible with `Literal["a", "b"]`
   - `int` should NOT be compatible with `Literal[1, 2]`

7. **test_literal_different_values_not_compatible** - No overlap
   - `Literal["x"]` should NOT be compatible with `Literal["a", "b"]`

**Expected behavior:** If current implementation doesn't handle Literal, tests document expected behavior. Use `pytest.mark.xfail(reason="...")` if needed to mark expected failures.

**Pattern:** Follow existing test class style (docstrings, assert statements).
  </action>
  <verify>uv run pytest tests/test_typing.py::TestLiteralTypeCompatibility -v</verify>
  <done>
- TestLiteralTypeCompatibility class exists with 7 tests
- Tests either pass (Literal handling works) or are marked xfail (documents gap)
- No syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Protocol, TypedDict, NamedTuple tests (TYPE-02, TYPE-03, TYPE-04)</name>
  <files>tests/test_typing.py</files>
  <action>
Add three new test classes for structural types.

**Imports:** Add to typing imports: `Protocol, TypedDict, runtime_checkable`
Add from `typing import NamedTuple` (it's already a NamedTuple import but ensure full form)

**Class 1: TestProtocolTypeCompatibility (TYPE-02)**

1. **test_protocol_identical_compatible** - Same protocol is compatible
   - Define `class Readable(Protocol): def read(self) -> str: ...`
   - `Readable` is compatible with `Readable`

2. **test_class_implementing_protocol_compatible** - Structural typing
   - Class with `read()` method should be compatible with Readable protocol
   - Note: This tests structural typing - may require runtime_checkable decorator

3. **test_class_not_implementing_protocol_not_compatible** - Missing method
   - Class without `read()` method should NOT be compatible with Readable

4. **test_protocol_with_multiple_methods** - Multiple method requirements
   - Protocol with `read()` and `write()` - class must have both

**Class 2: TestTypedDictTypeCompatibility (TYPE-03)**

1. **test_typeddict_identical_compatible** - Same TypedDict is compatible
   - Define `class PersonDict(TypedDict): name: str; age: int`
   - `PersonDict` is compatible with `PersonDict`

2. **test_typeddict_into_dict_compatible** - TypedDict is a dict
   - `PersonDict` should be compatible with `dict[str, Any]` (or just `dict`)

3. **test_dict_into_typeddict_not_compatible** - Dict is less specific
   - `dict[str, Any]` should NOT be compatible with `PersonDict`

4. **test_typeddict_different_keys_not_compatible** - Different structure
   - `PersonDict` vs `AddressDict` with different keys

**Class 3: TestNamedTupleTypeCompatibility (TYPE-04)**

1. **test_namedtuple_identical_compatible** - Same NamedTuple is compatible
   - Define `class Point(NamedTuple): x: int; y: int`
   - `Point` is compatible with `Point`

2. **test_namedtuple_into_tuple_compatible** - NamedTuple is a tuple
   - `Point` should be compatible with `tuple[int, int]`

3. **test_tuple_into_namedtuple_not_compatible** - Tuple lacks field names
   - `tuple[int, int]` should NOT be compatible with `Point`

4. **test_namedtuple_different_fields_not_compatible** - Different structure
   - `Point` vs `Vector` with different field names/types

**Expected behavior:** These advanced types may not be fully supported. Use `pytest.mark.xfail(reason="...")` for tests that document expected but unimplemented behavior.
  </action>
  <verify>uv run pytest tests/test_typing.py::TestProtocolTypeCompatibility tests/test_typing.py::TestTypedDictTypeCompatibility tests/test_typing.py::TestNamedTupleTypeCompatibility -v</verify>
  <done>
- Three test classes exist with tests for Protocol, TypedDict, NamedTuple
- Tests document expected behavior (pass or xfail)
- No syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add ParamSpec, Self, and Recursive type tests (TYPE-05, TYPE-06, TYPE-07)</name>
  <files>tests/test_typing.py</files>
  <action>
Add three more test classes for advanced typing constructs.

**Imports:**
- Add `ParamSpec` to typing imports
- Add `from typing import Self` (Python 3.11+) OR use `from typing_extensions import Self` with try/except fallback

**Class 1: TestParamSpecTypeCompatibility (TYPE-05)**

ParamSpec is used to preserve parameter types in decorators. Testing compatibility:

1. **test_paramspec_basic_handling** - ParamSpec doesn't crash
   - Define `P = ParamSpec("P")`
   - Test that `Callable[P, int]` can be compared without error
   - Should either return True (treated like unconstrained TypeVar) or gracefully degrade

2. **test_paramspec_in_callable_compatible** - Callable with ParamSpec
   - `Callable[P, int]` should be compatible with `Callable[..., int]` (or similar)

3. **test_paramspec_concat_handling** - ParamSpec.args/kwargs
   - Test that accessing `P.args`, `P.kwargs` doesn't cause errors

**Class 2: TestSelfTypeCompatibility (TYPE-06)**

Self type (Python 3.11+) refers to the class itself:

```python
# Handle import gracefully for Python < 3.11
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self
```

1. **test_self_type_basic_handling** - Self doesn't crash
   - Define class with `def clone(self) -> Self`
   - Test that Self type can be compared without error

2. **test_self_type_in_return_annotation** - Self as return type
   - Function returning Self should be compatible with the class type

3. **test_self_type_vs_explicit_class** - Self vs explicit class name
   - `Self` in context of class Foo should be compatible with `Foo`

**Class 3: TestRecursiveTypeCompatibility (TYPE-07)**

Recursive types can cause infinite loops. Test that they're handled:

1. **test_recursive_type_no_infinite_loop** - Direct recursion handled
   - Define: `JSON = Union[str, int, float, bool, None, list["JSON"], dict[str, "JSON"]]`
   - Compare `JSON` with `JSON` - should not hang
   - Use timeout or iteration limit in test if needed

2. **test_mutually_recursive_types_handled** - A references B, B references A
   - Test that mutual recursion doesn't cause stack overflow

3. **test_nested_recursive_compatible** - Nested recursive structures
   - `list[JSON]` should be compatible with `list[JSON]`

4. **test_recursive_type_depth_limit** - Very deep nesting handled
   - Create deeply nested type, verify no stack overflow

**Important for recursive types:** The implementation may need a recursion guard. If tests hang, mark them as xfail with reason explaining the gap.

**Pattern:** Use `pytest.mark.timeout(5)` for recursive type tests to prevent hanging. If pytest-timeout not available, use manual timeout mechanism.
  </action>
  <verify>uv run pytest tests/test_typing.py::TestParamSpecTypeCompatibility tests/test_typing.py::TestSelfTypeCompatibility tests/test_typing.py::TestRecursiveTypeCompatibility -v --timeout=10</verify>
  <done>
- Three test classes exist for ParamSpec, Self, Recursive types
- Tests handle import errors gracefully (Self may not be available)
- Tests have timeout protection for recursive types
- Tests document expected behavior
- No syntax errors or infinite loops
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/test_typing.py -v` runs all tests without hanging
- [ ] No syntax errors in test file
- [ ] Each TYPE requirement (01-07) has corresponding test class
- [ ] Tests that pass verify working functionality
- [ ] Tests that xfail document gaps with clear reason
- [ ] New test classes follow existing patterns (docstrings, assertions)
</verification>

<success_criteria>

- 7 new test classes added (one per TYPE requirement)
- Tests cover: Literal, Protocol, TypedDict, NamedTuple, ParamSpec, Self, Recursive
- Tests that pass confirm implementation works
- Tests marked xfail document expected behavior for gaps
- No infinite loops or hangs (timeout protection on recursive tests)
- All tests run without errors

</success_criteria>

<output>
After completion, create `.planning/phases/10-type-compatibility/10-01-SUMMARY.md`
</output>
