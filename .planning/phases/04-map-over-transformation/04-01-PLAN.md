---
phase: 04-map-over-transformation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hypergraph/nodes/function.py
  - src/hypergraph/nodes/graph_node.py
  - tests/test_nodes_function.py
  - tests/test_graph.py
autonomous: true

must_haves:
  truths:
    - "FunctionNode with map_over returns list[T] for mapped input parameter types"
    - "FunctionNode with map_over returns list[T] for output types"
    - "GraphNode with map_over returns list[T] for mapped input parameter types"
    - "GraphNode with map_over returns list[T] for output types"
    - "Type compatibility checking works with map_over transformed types"
  artifacts:
    - path: "src/hypergraph/nodes/function.py"
      provides: "FunctionNode.map_over() method and type transformation in annotations"
      contains: "_map_over"
    - path: "src/hypergraph/nodes/graph_node.py"
      provides: "GraphNode.map_over() method and type transformation in annotations"
      contains: "_map_over"
  key_links:
    - from: "FunctionNode.parameter_annotations"
      to: "_map_over"
      via: "wraps type in list[] if param in _map_over"
      pattern: "_map_over"
    - from: "FunctionNode.output_annotation"
      to: "_map_over"
      via: "wraps type in list[] if _map_over is set"
      pattern: "_map_over"
---

<objective>
Implement map_over type transformation for both FunctionNode and GraphNode.

Purpose: When a node has `map_over` configured, its type annotations should transform `T` â†’ `list[T]` for validation purposes. This enables strict_types mode to correctly validate connections where a mapped node expects/produces lists.

Output: FunctionNode and GraphNode with `map_over()` method and transformed type annotations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-type-extraction-infrastructure/01-01-SUMMARY.md
@.planning/phases/02-type-compatibility-engine/02-01-SUMMARY.md
@.planning/phases/03-enforcement-and-errors/03-01-SUMMARY.md

# Source files to modify:
@src/hypergraph/nodes/function.py
@src/hypergraph/nodes/graph_node.py

# For type wrapping logic:
@src/hypergraph/_typing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add map_over method and type transformation to FunctionNode</name>
  <files>src/hypergraph/nodes/function.py, tests/test_nodes_function.py</files>
  <action>
Add `map_over()` method to FunctionNode that returns a new instance with mapped parameters stored.

1. Add `_map_over: tuple[str, ...] | None = None` attribute initialized in `__init__`
2. Add `map_over(*params: str) -> Self` method that:
   - Validates params exist in self.inputs
   - Returns cloned node with `_map_over = params`
   - Follows immutable pattern like other `with_*` methods

3. Modify `parameter_annotations` property:
   - If `_map_over` is set and param is in `_map_over`, wrap type in `list[]`
   - Use `list[original_type]` syntax

4. Modify `output_annotation` property:
   - If `_map_over` is set (any inputs mapped), wrap ALL output types in `list[]`
   - Rationale: map_over produces list of results, so all outputs become lists

Example behavior:
```python
@node(output_name="result")
def process(x: int, config: str) -> float: ...

# Without map_over
process.parameter_annotations  # {'x': int, 'config': str}
process.output_annotation      # {'result': float}

# With map_over
mapped = process.map_over("x")
mapped.parameter_annotations   # {'x': list[int], 'config': str}
mapped.output_annotation       # {'result': list[float]}
```

Add tests for:
- map_over returns new FunctionNode instance (immutable)
- parameter_annotations transforms mapped param types to list[]
- non-mapped params retain original types
- output_annotation transforms to list[] when map_over is set
- map_over with invalid param raises ValueError
  </action>
  <verify>uv run pytest tests/test_nodes_function.py -v --tb=short</verify>
  <done>FunctionNode.map_over() works, parameter_annotations and output_annotation transform types correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add map_over method and type transformation to GraphNode</name>
  <files>src/hypergraph/nodes/graph_node.py, tests/test_graph.py</files>
  <action>
Add `map_over()` method to GraphNode with same pattern as FunctionNode.

1. Add `_map_over: tuple[str, ...] | None = None` attribute initialized in `__init__`
2. Add `map_over(*params: str) -> Self` method that:
   - Validates params exist in self.inputs
   - Returns cloned GraphNode with `_map_over = params`
   - Add `_copy()` helper method if not exists (follow FunctionNode pattern)

3. Add `parameter_annotations` property to GraphNode:
   - Delegate to inner graph's input nodes for parameter types
   - For each input, find which inner node(s) consume it and get their parameter type
   - If `_map_over` is set and param is in `_map_over`, wrap type in `list[]`

4. Modify existing `output_annotation` property:
   - If `_map_over` is set, wrap ALL output types in `list[]`

Implementation note for parameter_annotations:
- GraphNode inputs come from `self._graph.inputs.all`
- To get types, need to trace which inner nodes consume each input
- Build mapping: input_name -> type from inner node's parameter_annotations
- This mirrors how output_annotation already traces output sources

Add tests for:
- GraphNode.map_over returns new instance (immutable)
- GraphNode.parameter_annotations returns types from inner graph nodes
- GraphNode.parameter_annotations with map_over transforms types
- GraphNode.output_annotation with map_over transforms types
  </action>
  <verify>uv run pytest tests/test_graph.py -v -k "test_graphnode" --tb=short</verify>
  <done>GraphNode.map_over() works, parameter_annotations and output_annotation transform types correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for strict_types with map_over</name>
  <files>tests/test_graph.py</files>
  <action>
Add integration test that verifies the full type validation flow with map_over.

Test scenario:
```python
@node(output_name="items")
def generate(count: int) -> list[str]: ...

@node(output_name="result")
def process(item: str) -> int: ...

# Without map_over - type mismatch (list[str] vs str)
# With map_over on process("item") - type match (list[str] vs list[str])
```

Add test cases:
1. strict_types=True with map_over allows compatible list types
2. strict_types=True without map_over catches list vs non-list mismatch
3. Multiple nodes with map_over chain correctly

Verify the existing is_type_compatible handles list[T] correctly (Phase 2 implemented generics support).
  </action>
  <verify>uv run pytest tests/test_graph.py -v -k "strict" --tb=short</verify>
  <done>Integration tests pass for strict_types with map_over nodes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `uv run pytest tests/test_nodes_function.py -v` passes
- [ ] `uv run pytest tests/test_graph.py -v` passes
- [ ] `uv run pytest` all tests pass (full suite)
- [ ] No TypeScript errors: `uv run mypy src/hypergraph/` (if configured)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- FunctionNode.map_over() returns transformed types
- GraphNode.map_over() returns transformed types
- strict_types validation works with map_over nodes
- TYPE-07 requirement satisfied
  </success_criteria>

<output>
After completion, create `.planning/phases/04-map-over-transformation/04-01-SUMMARY.md`
</output>
