<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hypergraph â€” Use Case Explorer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0d1117;--panel:#161b22;--card:#1c2128;--hover:#262c36;
  --border:#30363d;--text:#c9d1d9;--dim:#8b949e;--bright:#f0f6fc;
  --blue:#58a6ff;--green:#3fb950;--red:#f85149;--amber:#d29922;
  --purple:#bc8cff;--cyan:#39d2c0;
  --mono:'SF Mono','Cascadia Code','JetBrains Mono',Consolas,monospace;
  --sans:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;
}
body{font-family:var(--sans);background:var(--bg);color:var(--text);height:100vh;overflow:hidden}
.app{display:grid;grid-template-columns:280px 1fr;grid-template-rows:auto 1fr;height:100vh}

/* Header */
.hdr{grid-column:1/-1;padding:10px 20px;border-bottom:1px solid var(--border);background:var(--panel);display:flex;align-items:center;gap:12px}
.hdr h1{font-size:15px;font-weight:600;color:var(--bright)}
.hdr .tag{font-size:10px;padding:2px 8px;border-radius:10px;background:#1f3a5f;color:var(--blue);font-weight:500}
.hdr .sub{margin-left:auto;font-size:11px;color:var(--dim)}

/* Sidebar */
.side{background:var(--panel);border-right:1px solid var(--border);overflow-y:auto;padding:12px}
.side-label{font-size:9px;font-weight:700;letter-spacing:1.2px;text-transform:uppercase;color:var(--dim);margin:12px 0 6px 4px}
.side-label:first-child{margin-top:4px}

.uc{padding:8px 10px;border-radius:6px;cursor:pointer;border:1px solid transparent;margin-bottom:2px;transition:all .12s}
.uc:hover{background:var(--hover)}
.uc.active{background:var(--card);border-color:var(--blue)}
.uc .uc-id{font-size:10px;font-weight:700;color:var(--dim);margin-bottom:1px}
.uc .uc-title{font-size:12px;font-weight:600;color:var(--bright);line-height:1.3}
.uc .uc-note{font-size:10px;color:var(--dim);margin-top:2px}
.uc .pill{display:inline-block;font-size:9px;padding:1px 5px;border-radius:3px;font-weight:600;margin-top:3px}
.pill-ok{background:#0d2818;color:var(--green)}
.pill-gap{background:#3d1f00;color:var(--amber)}
.pill-defer{background:#21162a;color:var(--purple)}

/* Main */
.main{overflow-y:auto;padding:16px 20px 60px;display:flex;flex-direction:column;gap:12px}

/* Toggle */
.toggle-bar{display:flex;gap:0;border-radius:8px;overflow:hidden;border:1px solid var(--border);align-self:flex-start}
.toggle-btn{padding:6px 18px;font-size:12px;font-family:var(--sans);background:var(--card);color:var(--dim);border:none;cursor:pointer;font-weight:600;transition:all .12s}
.toggle-btn.active{background:var(--blue);color:#0d1117}
.toggle-btn + .toggle-btn{border-left:1px solid var(--border)}

/* Section */
.section{background:var(--card);border:1px solid var(--border);border-radius:8px}
.sec-hdr{padding:8px 14px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:8px}
.sec-hdr .dot{width:7px;height:7px;border-radius:50%;flex-shrink:0}
.sec-hdr h3{font-size:12px;font-weight:600;color:var(--bright)}
.sec-hdr .badge{font-size:9px;padding:1px 6px;border-radius:3px;margin-left:auto;font-weight:600}

pre.code{font-family:var(--mono);font-size:11.5px;line-height:1.55;padding:12px 14px;overflow-x:auto;white-space:pre;color:var(--text);max-height:520px;overflow-y:auto}
pre.code code{font-family:inherit;font-size:inherit;background:none;padding:0}

/* Prism overrides to match our theme */
code[class*="language-"],pre[class*="language-"]{color:var(--text);background:none;font-family:var(--mono);font-size:11.5px;line-height:1.55;text-shadow:none}
.token.comment,.token.prolog,.token.doctype,.token.cdata{color:#6e7681}
.token.punctuation{color:var(--text)}
.token.property,.token.tag,.token.boolean,.token.number,.token.constant,.token.symbol{color:var(--amber)}
.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin{color:var(--green)}
.token.operator,.token.entity,.token.url,.language-css .token.string,.style .token.string{color:var(--text)}
.token.atrule,.token.attr-value,.token.keyword{color:var(--purple)}
.token.function,.token.class-name{color:var(--blue)}
.token.regex,.token.important,.token.variable{color:var(--cyan)}

/* Implementation note */
.impl-note{padding:10px 14px;font-size:11px;line-height:1.5;border-top:1px solid var(--border)}
.impl-note .label{font-weight:700;margin-right:4px}
.impl-note.gap{background:#1a1400;color:var(--amber)}
.impl-note.ok{background:#0a1a0e;color:var(--green)}
.impl-note.defer{background:#150e1e;color:var(--purple)}
</style>
</head>
<body>
<div class="app">
<div class="hdr">
  <h1>Hypergraph Use Cases</h1>
  <span class="tag">generated</span>
  <span class="sub">Real output from <code>uv run python examples/generate_playground.py</code></span>
</div>
<div class="side" id="sidebar"></div>
<div class="main" id="main"></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-bash.min.js"></script>
<script>
const UCS = [{"id": "uc1", "label": "UC1", "title": "\"Why was my run slow?\"", "note": "RunLog timing, node_stats, summary", "category": "tracing", "status": "ok", "impl_note": "Fully implemented. RunLog is always-on, zero config.", "single_python": "runner = SyncRunner()\ngraph = Graph([double, triple])\nresult = runner.run(graph, {&quot;x&quot;: 5})\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;2 nodes | 1ms | 0 errors | slowest: double (0ms)&#x27;\n\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 1ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; result.log.timing\n{&#x27;double&#x27;: 0.013, &#x27;triple&#x27;: 0.004}\n\n&gt;&gt;&gt; result.log.node_stats\n  double: count=1, avg=0.0ms, errors=0\n  triple: count=1, avg=0.0ms, errors=0", "single_cli": "", "mapped_python": "results = runner.map(graph, {&quot;x&quot;: [1, 2, 3, 4, 5]}, map_over=&quot;x&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;5 items | 5 completed | 1ms&#x27;\n\n# Drill into one item \u2014 same RunLog API as Single\n&gt;&gt;&gt; print(results[0].log)\nRunLog: None | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; results[0].log.timing\n{&#x27;double&#x27;: 0.004, &#x27;triple&#x27;: 0.005}\n\n&gt;&gt;&gt; results[0].log.node_stats\n  double: count=1, avg=0.0ms, errors=0\n  triple: count=1, avg=0.0ms, errors=0", "mapped_cli": "", "nested_python": "inner = Graph([double, triple], name=&quot;pipeline&quot;)\nouter = Graph([inner.as_node().map_over(&quot;x&quot;)])\nresult = runner.run(outer, {&quot;x&quot;: [1, 2, 3, 4, 5]})\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 1ms | 0 errors | slowest: pipeline (1ms)&#x27;\n\n# print() reveals &quot;(5 inner)&quot; \u2014 there&#x27;s more inside this step\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 1ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            pipeline          1ms               completed (5 inner)\n\n# Drill into one inner run \u2014 same RunLog API as Single\n&gt;&gt;&gt; step = result.log.steps[0]\n&gt;&gt;&gt; print(step.inner_logs[0])\nRunLog: pipeline | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; step.inner_logs[0].timing\n{&#x27;double&#x27;: 0.003, &#x27;triple&#x27;: 0.001}", "nested_cli": ""}, {"id": "uc10", "label": "UC10", "title": "\"Process a batch of items\"", "note": "runner.map() \u2192 MapResult", "category": "map", "status": "ok", "impl_note": "Fully implemented. MapResult wraps per-item RunResults with batch metadata.", "single_python": "runner = SyncRunner()\ngraph = Graph([double, triple])\nresult = runner.run(graph, {&quot;x&quot;: 5})\n\n&gt;&gt;&gt; result[&quot;tripled&quot;]\n30\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;2 nodes | 0ms | 0 errors | slowest: double (0ms)&#x27;\n\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; result.log.timing\n{&#x27;double&#x27;: 0.003, &#x27;triple&#x27;: 0.002}", "single_cli": "", "mapped_python": "# runner.map() \u2014 run the same graph on multiple inputs\nresults = runner.map(graph, {&quot;x&quot;: [1, 2, 3, 4, 5]}, map_over=&quot;x&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;5 items | 5 completed | 0ms&#x27;\n\n&gt;&gt;&gt; results[&quot;tripled&quot;]\n[6, 12, 18, 24, 30]\n\n# Drill into one item \u2014 same RunLog API as Single\n&gt;&gt;&gt; print(results[0].log)\nRunLog: None | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; results[0].log.timing\n{&#x27;double&#x27;: 0.002, &#x27;triple&#x27;: 0.001}", "mapped_cli": "# runner.map() runs are ephemeral (not checkpointed)\n# Each result has .log for per-item tracing", "nested_python": "# map_over \u2014 same batch, different semantics\ninner = Graph([double, triple], name=&quot;pipeline&quot;)\nouter = Graph([inner.as_node().map_over(&quot;x&quot;)])\nresult = runner.run(outer, {&quot;x&quot;: [1, 2, 3, 4, 5]})\n\n&gt;&gt;&gt; result[&quot;tripled&quot;]\n[6, 12, 18, 24, 30]\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 1ms | 0 errors | slowest: pipeline (1ms)&#x27;\n\n# print() reveals &quot;(5 inner)&quot; \u2014 there&#x27;s more inside this step\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 1ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            pipeline          1ms               completed (5 inner)\n\n# Drill into one inner run \u2014 same RunLog API as Single\n&gt;&gt;&gt; step = result.log.steps[0]\n&gt;&gt;&gt; print(step.inner_logs[0])\nRunLog: pipeline | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; step.inner_logs[0].timing\n{&#x27;double&#x27;: 0.002, &#x27;triple&#x27;: 0.001}", "nested_cli": ""}, {"id": "uc11", "label": "UC11", "title": "\"Nested graph over a list\"", "note": "GraphNode.map_over() \u2192 list outputs", "category": "map", "status": "ok", "impl_note": "Fully implemented. map_over wraps outputs in list[T] automatically.", "single_python": "# Nested graph: inner runs as a single node in outer\ninner = Graph([double, triple], name=&quot;pipeline&quot;)\nouter = Graph([inner.as_node()])\nresult = runner.run(outer, {&quot;x&quot;: 5})\n\n&gt;&gt;&gt; result[&quot;tripled&quot;]\n30\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 0ms | 0 errors | slowest: pipeline (0ms)&#x27;\n\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 0ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            pipeline          0ms               completed (1 inner)\n\n# Drill into inner execution\n&gt;&gt;&gt; step = result.log.steps[0]\n&gt;&gt;&gt; print(step.inner_logs[0])\nRunLog: pipeline | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; step.inner_logs[0].timing\n{&#x27;double&#x27;: 0.002, &#x27;triple&#x27;: 0.001}", "single_cli": "", "mapped_python": "# runner.map() on a nested graph \u2014 N independent runs\nouter = Graph([inner.as_node()])\nresults = runner.map(outer, {&quot;x&quot;: [1, 2, 3, 4, 5]}, map_over=&quot;x&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;5 items | 5 completed | 2ms&#x27;\n\n&gt;&gt;&gt; results[&quot;tripled&quot;]\n[6, 12, 18, 24, 30]\n\n# Drill into one item \u2014 same RunLog API as Single\n&gt;&gt;&gt; print(results[0].log)\nRunLog: None | 0ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            pipeline          0ms               completed (1 inner)\n\n&gt;&gt;&gt; results[0].log.steps[0].inner_logs[0].timing\n{&#x27;double&#x27;: 0.025, &#x27;triple&#x27;: 0.004}", "mapped_cli": "", "nested_python": "# map_over \u2014 inner graph runs once per item, outputs become lists\nouter = Graph([inner.as_node().map_over(&quot;x&quot;)])\nresult = runner.run(outer, {&quot;x&quot;: [1, 2, 3, 4, 5]})\n\n&gt;&gt;&gt; result[&quot;tripled&quot;]\n[6, 12, 18, 24, 30]\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 1ms | 0 errors | slowest: pipeline (0ms)&#x27;\n\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 1ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            pipeline          0ms               completed (5 inner)\n\n# Drill into one inner run \u2014 same RunLog API as Single\n&gt;&gt;&gt; step = result.log.steps[0]\n&gt;&gt;&gt; print(step.inner_logs[0])\nRunLog: pipeline | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            double            0ms               completed\n     1            triple            0ms               completed\n\n&gt;&gt;&gt; step.inner_logs[0].timing\n{&#x27;double&#x27;: 0.003, &#x27;triple&#x27;: 0.001}", "nested_cli": ""}, {"id": "uc12", "label": "UC12", "title": "\"Every combination of inputs\"", "note": "map_over mode='product' vs 'zip'", "category": "map", "status": "ok", "impl_note": "Fully implemented. zip (default) for parallel, product for cartesian.", "single_python": "inner = Graph([add], name=&quot;adder&quot;)\nouter = Graph([inner.as_node()])\nresult = runner.run(outer, {&quot;a&quot;: 10, &quot;b&quot;: 20})\n\n&gt;&gt;&gt; result[&quot;sum&quot;]\n30\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 0ms | 0 errors | slowest: adder (0ms)&#x27;\n\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 0ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            adder             0ms               completed (1 inner)", "single_cli": "", "mapped_python": "# runner.map() maps one param \u2014 b is shared across all items\nresults = runner.map(outer, {&quot;a&quot;: [1, 2, 3], &quot;b&quot;: 10}, map_over=&quot;a&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;3 items | 3 completed | 0ms&#x27;\n\n&gt;&gt;&gt; results[&quot;sum&quot;]\n[11, 12, 13]\n\n# Drill into one item \u2014 same RunLog API as Single\n&gt;&gt;&gt; print(results[0].log)\nRunLog: None | 0ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            adder             0ms               completed (1 inner)", "mapped_cli": "", "nested_python": "# mode=&quot;product&quot; \u2014 cartesian product of mapped params\nouter = Graph([inner.as_node().map_over(&quot;a&quot;, &quot;b&quot;, mode=&quot;product&quot;)])\nresult = runner.run(outer, {&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [10, 20]})\n\n# 3 \u00d7 2 = 6 combinations\n&gt;&gt;&gt; result[&quot;sum&quot;]\n[11, 21, 12, 22, 13, 23]\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 0ms | 0 errors | slowest: adder (0ms)&#x27;\n\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 0ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            adder             0ms               completed (6 inner)\n\n# zip mode (default) requires equal-length lists\nouter_zip = Graph([inner.as_node().map_over(&quot;a&quot;, &quot;b&quot;)])\nresult_zip = runner.run(outer_zip, {&quot;a&quot;: [1, 2], &quot;b&quot;: [10, 20]})\n&gt;&gt;&gt; result_zip[&quot;sum&quot;]\n[11, 22]", "nested_cli": ""}, {"id": "uc2", "label": "UC2", "title": "\"What failed and why?\"", "note": "Error tracking, partial failures", "category": "tracing", "status": "ok", "impl_note": "Fully implemented. error_handling='continue' works in both run() and map().", "single_python": "graph = Graph([succeed_a, fail_b])\nresult = runner.run(graph, {&quot;x&quot;: 1}, error_handling=&quot;continue&quot;)\n\n&gt;&gt;&gt; result.status\nRunStatus.FAILED\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;2 nodes | 0ms | 1 errors | slowest: fail_b (0ms)&#x27;\n\n&gt;&gt;&gt; result.log.errors\n  fail_b: b failed\n\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 0ms | 2 nodes | 1 error\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            succeed_a         0ms               completed\n     1            fail_b            0ms               FAILED: b failed", "single_cli": "", "mapped_python": "results = runner.map(\n    fail_graph, {&quot;x&quot;: [1, 2, 3, 4, 5]},\n    map_over=&quot;x&quot;, error_handling=&quot;continue&quot;,\n)\n\n&gt;&gt;&gt; results.status\nRunStatus.FAILED\n\n&gt;&gt;&gt; results.summary()\n&#x27;5 items | 4 completed, 1 failed | 0ms&#x27;\n\n# Drill into the failed item \u2014 same RunLog API as Single\n&gt;&gt;&gt; results.failures[0].log.errors\n  maybe_fail: x=3 is not allowed\n\n&gt;&gt;&gt; print(results.failures[0].log)\nRunLog: None | 0ms | 1 nodes | 1 error\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            maybe_fail        0ms               FAILED: x=3 is not allowed", "mapped_cli": "", "nested_python": "inner = Graph([maybe_fail], name=&quot;checker&quot;)\nouter = Graph([inner.as_node().map_over(&quot;x&quot;, error_handling=&quot;continue&quot;)])\nresult = runner.run(outer, {&quot;x&quot;: [1, 2, 3, 4, 5]}, error_handling=&quot;continue&quot;)\n\n&gt;&gt;&gt; result.status\nRunStatus.COMPLETED\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 1ms | 0 errors | slowest: checker (1ms)&#x27;\n\n# print() reveals &quot;(5 inner)&quot; \u2014 there&#x27;s more inside this step\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 1ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            checker           1ms               completed (5 inner)\n\n# Drill into inner_logs \u2014 same RunLog API as Single\n&gt;&gt;&gt; failed = [log for log in result.log.steps[0].inner_logs if log.errors]\n&gt;&gt;&gt; failed[0].errors[0].error\n&#x27;x=3 is not allowed&#x27;\n\n&gt;&gt;&gt; print(failed[0])\nRunLog: checker | 0ms | 1 nodes | 1 error\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            maybe_fail        0ms               FAILED: x=3 is not allowed", "nested_cli": ""}, {"id": "uc3", "label": "UC3", "title": "\"What path did execution take?\"", "note": "Gate routing, cyclic re-execution", "category": "tracing", "status": "ok", "impl_note": "Fully implemented. RunLog tracks routing decisions and re-executions.", "single_python": "# Cyclic graph: increment \u2192 check_done \u2192 (loop or END)\ngraph = Graph([increment, check_done])\nresult = runner.run(graph, {&quot;count&quot;: 0})\n\n&gt;&gt;&gt; result[&quot;count&quot;]\n3\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;2 nodes | 0ms | 0 errors | slowest: check_done (0ms)&#x27;\n\n# RunLog shows every re-execution with routing decisions\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status            Decision\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            check_done        0ms               completed         \u2192 increment\n     1            increment         0ms               completed\n     2            check_done        0ms               completed         \u2192 increment\n     3            increment         0ms               completed\n     4            check_done        0ms               completed         \u2192 increment\n     5            increment         0ms               completed\n     6            check_done        0ms               completed         \u2192 END\n\n&gt;&gt;&gt; result.log.node_stats\n  check_done: count=4, avg=0.0ms, errors=0\n  increment: count=3, avg=0.0ms, errors=0", "single_cli": "", "mapped_python": "# runner.map() on a cyclic graph \u2014 each item gets its own RunLog with routing\nresults = runner.map(graph, {&quot;count&quot;: [0, 1, 2]}, map_over=&quot;count&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;3 items | 3 completed | 1ms&#x27;\n\n&gt;&gt;&gt; results[&quot;count&quot;]\n[3, 3, 3]\n\n# Drill into one item \u2014 same RunLog API as Single\n&gt;&gt;&gt; print(results[0].log)\nRunLog: None | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status            Decision\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            check_done        0ms               completed         \u2192 increment\n     1            increment         0ms               completed\n     2            check_done        0ms               completed         \u2192 increment\n     3            increment         0ms               completed\n     4            check_done        0ms               completed         \u2192 increment\n     5            increment         0ms               completed\n     6            check_done        0ms               completed         \u2192 END\n\n&gt;&gt;&gt; results[0].log.node_stats\n  check_done: count=4, avg=0.0ms, errors=0\n  increment: count=3, avg=0.0ms, errors=0", "mapped_cli": "", "nested_python": "# map_over \u2014 drill into per-item routing via inner_logs\ninner = Graph([increment, check_done], name=&quot;counter&quot;)\nouter = Graph([inner.as_node().map_over(&quot;count&quot;)])\nresult = runner.run(outer, {&quot;count&quot;: [0, 1, 2]})\n\n&gt;&gt;&gt; result[&quot;count&quot;]\n[3, 3, 3]\n\n&gt;&gt;&gt; result.log.summary()\n&#x27;1 nodes | 1ms | 0 errors | slowest: counter (1ms)&#x27;\n\n# print() reveals &quot;(3 inner)&quot; \u2014 there&#x27;s more inside this step\n&gt;&gt;&gt; print(result.log)\nRunLog: None | 1ms | 1 nodes | 0 errors\n\n  Step            Node              Duration          Status\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            counter           1ms               completed (3 inner)\n\n# Drill into one inner run \u2014 same RunLog API as Single\n&gt;&gt;&gt; step = result.log.steps[0]\n&gt;&gt;&gt; print(step.inner_logs[0])\nRunLog: counter | 0ms | 2 nodes | 0 errors\n\n  Step            Node              Duration          Status            Decision\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0            check_done        0ms               completed         \u2192 increment\n     1            increment         0ms               completed\n     2            check_done        0ms               completed         \u2192 increment\n     3            increment         0ms               completed\n     4            check_done        0ms               completed         \u2192 increment\n     5            increment         0ms               completed\n     6            check_done        0ms               completed         \u2192 END\n\n&gt;&gt;&gt; step.inner_logs[0].node_stats\n  check_done: count=4, avg=0.0ms, errors=0\n  increment: count=3, avg=0.0ms, errors=0", "nested_cli": ""}, {"id": "uc4", "label": "UC4", "title": "\"What values flowed through?\"", "note": "Intermediate values via checkpointer", "category": "persistence", "status": "ok", "impl_note": "Fully implemented. Sync reads: cp.state(), cp.steps(), cp.checkpoint().", "single_python": "cp = SqliteCheckpointer(&quot;./workflows.db&quot;, durability=&quot;sync&quot;)\nrunner = AsyncRunner(checkpointer=cp)\nresult = await runner.run(graph, {&quot;x&quot;: 5}, workflow_id=&quot;uc4-single&quot;)\n\n# Sync reads \u2014 no await needed\n&gt;&gt;&gt; cp.state(&quot;uc4-single&quot;)\n{&#x27;doubled&#x27;: 10, &#x27;tripled&#x27;: 30}\n\n&gt;&gt;&gt; cp.steps(&quot;uc4-single&quot;)\n  [0] double: completed (0.0ms) \u2192 {&#x27;doubled&#x27;: 10}\n  [1] triple: completed (0.0ms) \u2192 {&#x27;tripled&#x27;: 30}\n\n&gt;&gt;&gt; cp.checkpoint(&quot;uc4-single&quot;)\n  values: {&#x27;doubled&#x27;: 10, &#x27;tripled&#x27;: 30}\n  steps: 2", "single_cli": "$ hypergraph workflows state uc4-single --values --db &lt;db&gt;\n\n\nState: uc4-single (through step 1)\n\n  doubled: 10\n  tripled: 30\n  To save to file: --output state.json", "mapped_python": "# runner.map() is ephemeral \u2014 per-item RunLogs but no persistence\nrunner_sync = SyncRunner()\nresults = runner_sync.map(graph, {&quot;x&quot;: [5, 10, 15]}, map_over=&quot;x&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;3 items | 3 completed | 11ms&#x27;\n\n&gt;&gt;&gt; results[&quot;tripled&quot;]\n[30, 60, 90]\n\n# Not checkpointed \u2014 cp.workflows() won&#x27;t show these runs\n# Use map_over with a checkpointer for persistence", "mapped_cli": "# runner.map() runs are ephemeral \u2014 no CLI queries available", "nested_python": "# map_over in a checkpointed run \u2014 the outer graph persists as one workflow\ninner = Graph([double, triple], name=&quot;pipeline&quot;)\nouter = Graph([inner.as_node().map_over(&quot;x&quot;)])\nresult = await runner.run(outer, {&quot;x&quot;: [5, 10, 15]}, workflow_id=&quot;uc4-multi&quot;)\n\n&gt;&gt;&gt; result[&quot;tripled&quot;]\n[30, 60, 90]\n\n# The workflow contains one step (the mapped GraphNode)\n&gt;&gt;&gt; cp.state(&quot;uc4-multi&quot;)\n{&#x27;doubled&#x27;: [10, 20, 30], &#x27;tripled&#x27;: [30, 60, 90]}\n\n&gt;&gt;&gt; cp.steps(&quot;uc4-multi&quot;)\n  [0] pipeline: completed (12.6ms) \u2192 {&#x27;doubled&#x27;: [10, 20, 30], &#x27;tripled&#x27;: [30, 60, 90]}", "nested_cli": "$ hypergraph workflows state uc4-multi --values --db &lt;db&gt;\n\n\nState: uc4-multi (through step 0)\n\n  doubled: [10, 20, 30]\n  tripled: [30, 60, 90]\n  To save to file: --output state.json"}, {"id": "uc5", "label": "UC5", "title": "\"What happened in yesterday's run?\"", "note": "Cross-process persistence", "category": "persistence", "status": "ok", "impl_note": "Fully implemented. Sync reads work from any process without async.", "single_python": "# In a NEW process \u2014 query old workflows (sync, no await)\ncp = SqliteCheckpointer(&quot;./workflows.db&quot;)\n\n&gt;&gt;&gt; cp.workflows()\n    uc4-multi: completed\n  uc4-single: completed\n\n&gt;&gt;&gt; cp.state(&quot;uc4-single&quot;)\n{&#x27;doubled&#x27;: 10, &#x27;tripled&#x27;: 30}\n\n&gt;&gt;&gt; cp.steps(&quot;uc4-single&quot;)\n  [0] double: completed (0.0ms) \u2192 {&#x27;doubled&#x27;: 10}\n  [1] triple: completed (0.0ms) \u2192 {&#x27;tripled&#x27;: 30}", "single_cli": "$ hypergraph workflows ls --db &lt;db&gt;\n\n\nWorkflows (2 total)\n\n  ID          Status     Created         \n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  uc4-multi   completed  2026-02-28 12:48\n  uc4-single  completed  2026-02-28 12:48\n\n  To inspect a workflow: hypergraph workflows show &lt;id&gt;\n  To filter: --status, --limit N", "mapped_python": "# runner.map() is ephemeral \u2014 results exist only in the current process\nresults = runner.map(graph, {&quot;x&quot;: [5, 10, 15]}, map_over=&quot;x&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;3 items | 3 completed | 1ms&#x27;\n\n# After the process exits, these results are gone\n# cp.workflows() won&#x27;t show runner.map() runs\n&gt;&gt;&gt; cp.workflows()\n    uc4-multi: completed\n  uc4-single: completed\n\n# Use map_over with a checkpointer for cross-process persistence", "mapped_cli": "# runner.map() runs are ephemeral \u2014 nothing to query from CLI", "nested_python": "# The mapped workflow is also queryable from a new process\n&gt;&gt;&gt; cp.state(&quot;uc4-multi&quot;)\n{&#x27;doubled&#x27;: [10, 20, 30], &#x27;tripled&#x27;: [30, 60, 90]}\n\n&gt;&gt;&gt; cp.workflows()\n    uc4-multi: completed\n  uc4-single: completed", "nested_cli": "$ hypergraph workflows show uc4-multi --db &lt;db&gt;\n\n\nWorkflow: uc4-multi | completed | 1 steps | 13ms\n\n  Step  Node      Duration  Status     Decision\n  \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0  pipeline      13ms  completed          \n\n  To see values at a superstep: hypergraph workflows state uc4-multi --superstep N\n  To see error details:    hypergraph workflows steps uc4-multi --node &lt;name&gt;\n  To save full trace:      hypergraph workflows show uc4-multi --json --output trace.json"}, {"id": "uc6", "label": "UC6", "title": "\"Show me all failed workflows\"", "note": "Dashboard, status filtering", "category": "persistence", "status": "ok", "impl_note": "Fully implemented. Filter by status via Python API or CLI.", "single_python": "&gt;&gt;&gt; cp.workflows()\n    uc6-failed: failed\n  uc4-multi: completed\n  uc4-single: completed\n\n&gt;&gt;&gt; cp.workflows(status=WorkflowStatus.FAILED)\n    uc6-failed: failed\n\n# Drill into the failed workflow\n&gt;&gt;&gt; cp.steps(&quot;uc6-failed&quot; if failed else &quot;???&quot;)\n  [0] succeed_a: completed (0.0ms) \u2192 {&#x27;a_out&#x27;: 2}\n  [1] fail_b: failed (0.0ms) \u2014 b failed", "single_cli": "$ hypergraph workflows --db &lt;db&gt;\n\n\nRecent (last 3)\n\n  ID          Status     Steps  Created         \n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  uc6-failed  FAILED         2  2026-02-28 12:48\n  uc4-multi   completed      1  2026-02-28 12:48\n  uc4-single  completed      2  2026-02-28 12:48\n\n  To inspect a workflow: hypergraph workflows show &lt;id&gt;\n  To see all workflows: hypergraph workflows ls\n  To filter failures:   hypergraph workflows ls --status failed", "mapped_python": "# runner.map() \u2014 in-process filtering via MapResult (ephemeral)\nresults = runner.map(\n    flaky_graph, {&quot;x&quot;: [1, 2, 3, 4, 5, 6]},\n    map_over=&quot;x&quot;, error_handling=&quot;continue&quot;,\n)\n\n&gt;&gt;&gt; results.summary()\n&#x27;6 items | 4 completed, 2 failed | 1ms&#x27;\n\n&gt;&gt;&gt; results.failed\nTrue\n\n&gt;&gt;&gt; [f.error for f in results.failures]\n[ValueError(&#x27;x=3 is banned&#x27;), ValueError(&#x27;x=6 is banned&#x27;)]\n\n# In-process only \u2014 not persisted to checkpointer\n# For persistent failure tracking, use map_over with a checkpointer", "mapped_cli": "# runner.map() failures are ephemeral \u2014 use MapResult.failures in-process", "nested_python": "# The dashboard shows all workflows \u2014 single runs and mapped runs\n&gt;&gt;&gt; cp.workflows()\n    uc6-failed: failed\n  uc4-multi: completed\n  uc4-single: completed\n\n&gt;&gt;&gt; cp.workflows(status=WorkflowStatus.COMPLETED)\n    uc4-multi: completed\n  uc4-single: completed", "nested_cli": "$ hypergraph workflows ls --status completed --db &lt;db&gt;\n\n\nWorkflows (2 total)\n\n  ID          Status     Created         \n  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  uc4-multi   completed  2026-02-28 12:48\n  uc4-single  completed  2026-02-28 12:48\n\n  To inspect a workflow: hypergraph workflows show &lt;id&gt;\n  To filter: --status, --limit N"}, {"id": "uc7", "label": "UC7", "title": "AI Agent Debugging", "note": "Structured JSON for agents", "category": "tracing", "status": "ok", "impl_note": "Fully implemented. .to_dict() for Python, --json for CLI.", "single_python": "result = runner.run(graph, {&quot;x&quot;: 5})\n\n# Machine-readable trace for agents\n&gt;&gt;&gt; json.dumps(result.log.to_dict(), indent=2)\n{\n  &quot;graph_name&quot;: null,\n  &quot;run_id&quot;: &quot;run-4f749a4fe48d&quot;,\n  &quot;total_duration_ms&quot;: 0.059,\n  &quot;steps&quot;: [\n    {\n      &quot;node_name&quot;: &quot;double&quot;,\n      &quot;superstep&quot;: 0,\n      &quot;duration_ms&quot;: 0.002,\n      &quot;status&quot;: &quot;completed&quot;,\n      &quot;span_id&quot;: &quot;82db20ed16634eff&quot;,\n      &quot;error&quot;: null,\n      &quot;cached&quot;: false,\n      &quot;decision&quot;: null,\n      &quot;inner_logs&quot;: []\n    },\n    {\n      &quot;node_name&quot;: &quot;triple&quot;,\n      &quot;superstep&quot;: 1,\n      &quot;duration_ms&quot;: 0.002,\n      &quot;status&quot;: &quot;completed&quot;,\n      &quot;span_id&quot;: &quot;2d2359aa983948a1&quot;,\n      &quot;error&quot;: null,\n      &quot;cached&quot;: false,\n      &quot;decision&quot;: null,\n      &quot;inner_logs&quot;: []\n    }\n  ],\n  ... (truncated)", "single_cli": "$ hypergraph workflows --help\n\n                                                                                \n Usage: hypergraph workflows [OPTIONS] COMMAND [ARGS]...                        \n                                                                                \n Inspect and manage workflow executions.                                        \n                                                                                \n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --db            TEXT  Database path [default: ./workflows.db]                \u2502\n\u2502 --json                Output as JSON                                         \u2502\n\u2502 --output        TEXT  Write JSON to file                                     \u2502\n\u2502 --help                Show this message and exit.                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 ls      List workflows with filters.                                         \u2502\n\u2502 show    Show execution trace for a workflow.                                 \u2502\n\u2502 state   Show accumulated values at a point in execution.                     \u2502\n\u2502 steps   Show detailed step records.                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f", "mapped_python": "results = runner.map(graph, {&quot;x&quot;: [1, 2, 3]}, map_over=&quot;x&quot;)\n\n# Batch-level JSON export (includes per-item metadata)\n&gt;&gt;&gt; json.dumps(results.to_dict(), indent=2)\n{\n  &quot;run_id&quot;: &quot;run-8073bb7db2c5&quot;,\n  &quot;total_duration_ms&quot;: 0.6961822509765625,\n  &quot;map_over&quot;: [\n    &quot;x&quot;\n  ],\n  &quot;map_mode&quot;: &quot;zip&quot;,\n  &quot;graph_name&quot;: &quot;&quot;,\n  &quot;item_count&quot;: 3,\n  &quot;completed_count&quot;: 3,\n  &quot;failed_count&quot;: 0,\n  &quot;items&quot;: [\n    {\n      &quot;status&quot;: &quot;completed&quot;,\n      &quot;run_id&quot;: &quot;run-a8b134024a7a&quot;,\n      &quot;workflow_id&quot;: null,\n      &quot;log&quot;: {\n        &quot;graph_name&quot;: null,\n        &quot;run_id&quot;: &quot;run-a8b134024a7a&quot;,\n        &quot;total_duration_ms&quot;: 0.192,\n        &quot;steps&quot;: [\n          {\n            &quot;node_name&quot;: &quot;double&quot;,\n            &quot;superstep&quot;: 0,\n            &quot;duration_ms&quot;: 0.014,\n            &quot;status&quot;: &quot;completed&quot;\n  ... (truncated)\n\n# Per-item summaries via RunResult.summary()\n&gt;&gt;&gt; [r.summary() for r in results]\n[&#x27;2 nodes | 0ms | 0 errors | slowest: double (0ms)&#x27;, &#x27;2 nodes | 0ms | 0 errors | slowest: double (0ms)&#x27;, &#x27;2 nodes | 0ms | 0 errors | slowest: double (0ms)&#x27;]", "mapped_cli": "# runner.map() results are ephemeral \u2014 use .to_dict() per item\n# For persistent JSON, use map_over with a checkpointer + CLI --json", "nested_python": "# map_over \u2014 to_dict() includes recursive inner_logs\ninner = Graph([double, triple], name=&quot;pipeline&quot;)\nouter = Graph([inner.as_node().map_over(&quot;x&quot;)])\nresult = runner.run(outer, {&quot;x&quot;: [1, 2, 3]})\n\n# inner_logs appear in each step&#x27;s JSON \u2014 full recursive trace\n&gt;&gt;&gt; json.dumps(result.log.to_dict(), indent=2)\n{\n  &quot;graph_name&quot;: null,\n  &quot;run_id&quot;: &quot;run-852e4daaa1d7&quot;,\n  &quot;total_duration_ms&quot;: 0.752,\n  &quot;steps&quot;: [\n    {\n      &quot;node_name&quot;: &quot;pipeline&quot;,\n      &quot;superstep&quot;: 0,\n      &quot;duration_ms&quot;: 0.627,\n      &quot;status&quot;: &quot;completed&quot;,\n      &quot;span_id&quot;: &quot;13e1ed4c49464196&quot;,\n      &quot;error&quot;: null,\n      &quot;cached&quot;: false,\n      &quot;decision&quot;: null,\n      &quot;inner_logs&quot;: [\n        {\n          &quot;graph_name&quot;: &quot;pipeline&quot;,\n          &quot;run_id&quot;: &quot;run-f2926f36b116&quot;,\n          &quot;total_duration_ms&quot;: 0.091,\n          &quot;steps&quot;: [\n            {\n              &quot;node_name&quot;: &quot;double&quot;,\n              &quot;superstep&quot;: 0,\n              &quot;duration_ms&quot;: 0.004,\n              &quot;status&quot;: &quot;completed&quot;,\n              &quot;span_id&quot;: &quot;328783dcc3ef450e&quot;,\n              &quot;error&quot;: null,\n              &quot;cached&quot;: false,\n              &quot;decision&quot;: null,\n              &quot;inner_logs&quot;: []\n            },\n            {\n              &quot;node_name&quot;: &quot;triple&quot;,\n              &quot;superstep&quot;: 1,\n              &quot;duration_ms&quot;: 0.002,\n              &quot;status&quot;: &quot;completed&quot;,\n              &quot;span_id&quot;: &quot;e2e5ded187054f0d&quot;,\n              &quot;error&quot;: null,\n              &quot;cached&quot;: false,\n              &quot;decision&quot;: null,\n              &quot;inner_logs&quot;: []\n            }\n          ],\n          &quot;node_stats&quot;: {\n            &quot;double&quot;: {\n              &quot;count&quot;: 1,\n              &quot;total_ms&quot;: 0.004,\n              &quot;avg_ms&quot;: 0.004,\n              &quot;errors&quot;: 0,\n              &quot;cached&quot;: 0\n            },\n            &quot;triple\n  ... (truncated)\n\n# Agents can parse inner_logs to inspect per-item execution\n&gt;&gt;&gt; result.summary()\n&#x27;1 nodes | 1ms | 0 errors | slowest: pipeline (1ms)&#x27;", "nested_cli": ""}, {"id": "uc8", "label": "UC8", "title": "\"Where are we right now?\"", "note": "Live monitoring, durability modes", "category": "persistence", "status": "ok", "impl_note": "Fully implemented. Durability controls when data is queryable.", "single_python": "# durability=&quot;sync&quot; \u2014 data visible immediately for live queries\ncp = SqliteCheckpointer(&quot;./workflows.db&quot;, durability=&quot;sync&quot;)\nrunner = AsyncRunner(checkpointer=cp)\nawait runner.run(graph, {&quot;x&quot;: 5}, workflow_id=&quot;uc8-live&quot;)\n\n# Query from another process while running (or after)\ncp2 = SqliteCheckpointer(&quot;./workflows.db&quot;)\n&gt;&gt;&gt; cp2.state(&quot;uc8-live&quot;)\n{&#x27;doubled&#x27;: 10, &#x27;tripled&#x27;: 30}\n\n# Durability modes control when data is visible:\n#   &quot;async&quot;  \u2014 background writes (default, good balance)\n#   &quot;sync&quot;   \u2014 block until written (crash-safe)\n#   &quot;exit&quot;   \u2014 only at run completion (fastest)", "single_cli": "$ hypergraph workflows show uc8-live --db &lt;db&gt;\n\n\nWorkflow: uc8-live | completed | 2 steps | 0ms\n\n  Step  Node    Duration  Status     Decision\n  \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0  double       0ms  completed          \n     1  triple       0ms  completed          \n\n  To see values at a superstep: hypergraph workflows state uc8-live --superstep N\n  To see error details:    hypergraph workflows steps uc8-live --node &lt;name&gt;\n  To save full trace:      hypergraph workflows show uc8-live --json --output trace.json", "mapped_python": "# runner.map() is ephemeral \u2014 no live query from another process\nresults = runner.map(graph, {&quot;x&quot;: [5, 10]}, map_over=&quot;x&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;2 items | 2 completed | 2ms&#x27;\n\n&gt;&gt;&gt; results[&quot;tripled&quot;]\n[30, 60]\n\n# Not checkpointed \u2014 can&#x27;t query from CLI or another process\n# Durability modes only apply to checkpointer-backed runs", "mapped_cli": "# runner.map() is ephemeral \u2014 no CLI queries for live monitoring", "nested_python": "# map_over with durability=&quot;sync&quot; \u2014 each step visible immediately\ninner = Graph([double, triple], name=&quot;pipeline&quot;)\nouter = Graph([inner.as_node().map_over(&quot;x&quot;)])\nawait runner.run(outer, {&quot;x&quot;: [5, 10]}, workflow_id=&quot;uc8-multi&quot;)\n\n&gt;&gt;&gt; cp.state(&quot;uc8-multi&quot;)\n{&#x27;doubled&#x27;: [10, 20], &#x27;tripled&#x27;: [30, 60]}", "nested_cli": "$ hypergraph workflows show uc8-multi --db &lt;db&gt;\n\n\nWorkflow: uc8-multi | completed | 1 steps | 2ms\n\n  Step  Node      Duration  Status     Decision\n  \u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n     0  pipeline       2ms  completed          \n\n  To see values at a superstep: hypergraph workflows state uc8-multi --superstep N\n  To see error details:    hypergraph workflows steps uc8-multi --node &lt;name&gt;\n  To save full trace:      hypergraph workflows show uc8-multi --json --output trace.json"}, {"id": "uc9", "label": "UC9", "title": "\"Fork and retry from here\"", "note": "Checkpoint replay", "category": "persistence", "status": "defer", "impl_note": "Partially implemented. checkpoint() works; history= param deferred to v2.", "single_python": "# checkpoint() returns state + steps \u2014 a snapshot for forking\n&gt;&gt;&gt; cp.checkpoint(&quot;uc9-fork&quot;)\n  values: {&#x27;doubled&#x27;: 10, &#x27;tripled&#x27;: 30}\n  steps: 2\n\n# Use checkpoint values as inputs to a new run\nresult = await runner.run(\n    updated_graph,\n    values={**checkpoint.values},\n    workflow_id=&quot;uc9-fork-retry&quot;,\n)\n\n# NOT YET: history= parameter for true fork-and-retry\n# result = await runner.run(graph, values=..., history=checkpoint.steps)", "single_cli": "$ hypergraph workflows state uc9-fork --values --db &lt;db&gt;\n\n\nState: uc9-fork (through step 1)\n\n  doubled: 10\n  tripled: 30\n  To save to file: --output state.json", "mapped_python": "# runner.map() is ephemeral \u2014 can&#x27;t fork or retry from a checkpoint\nresults = runner.map(graph, {&quot;x&quot;: [5, 10]}, map_over=&quot;x&quot;)\n\n&gt;&gt;&gt; results.summary()\n&#x27;2 items | 2 completed | 0ms&#x27;\n\n# No checkpoint data \u2014 results exist only in-process\n# For fork-and-retry, use map_over with a checkpointer", "mapped_cli": "# runner.map() runs are ephemeral \u2014 no checkpoints to fork from", "nested_python": "# checkpoint() works for mapped workflows too\ninner = Graph([double, triple], name=&quot;pipeline&quot;)\nouter = Graph([inner.as_node().map_over(&quot;x&quot;)])\nawait runner.run(outer, {&quot;x&quot;: [5, 10]}, workflow_id=&quot;uc9-multi&quot;)\n\n&gt;&gt;&gt; cp.checkpoint(&quot;uc9-multi&quot;)\n  values: {&#x27;doubled&#x27;: [10, 20], &#x27;tripled&#x27;: [30, 60]}\n  steps: 1", "nested_cli": "$ hypergraph workflows state uc9-multi --values --db &lt;db&gt;\n\n\nState: uc9-multi (through step 0)\n\n  doubled: [10, 20]\n  tripled: [30, 60]\n  To save to file: --output state.json"}];
const CATEGORIES = [
  {key:'tracing', label:'Tracing'},
  {key:'persistence', label:'Persistence'},
  {key:'map', label:'Mapping'},
];

let state = { uc: UCS[0].id, view: 'single' };

function renderSidebar() {
  const sb = document.getElementById('sidebar');
  let h = '';
  for (const cat of CATEGORIES) {
    const items = UCS.filter(u => u.category === cat.key);
    if (!items.length) continue;
    h += `<div class="side-label">${cat.label}</div>`;
    for (const uc of items) {
      const cls = state.uc === uc.id ? ' active' : '';
      const pill = uc.status === 'ok' ? '<span class="pill pill-ok">implemented</span>'
                 : uc.status === 'gap' ? '<span class="pill pill-gap">has gaps</span>'
                 : '<span class="pill pill-defer">v2 deferred</span>';
      h += `<div class="uc${cls}" onclick="select('${uc.id}')">
        <div class="uc-id">${uc.label}</div>
        <div class="uc-title">${uc.title}</div>
        <div class="uc-note">${uc.note}</div>
        ${pill}
      </div>`;
    }
  }
  sb.innerHTML = h;
}

function select(id) { state.uc = id; render(); }
function setView(v) { state.view = v; render(); }

function render() {
  renderSidebar();
  const uc = UCS.find(u => u.id === state.uc);
  const m = document.getElementById('main');
  const v = state.view;

  const implCls = uc.status === 'ok' ? 'ok' : uc.status === 'gap' ? 'gap' : 'defer';
  const implLabel = uc.status === 'ok' ? 'Implemented' : uc.status === 'gap' ? 'Gap' : 'Deferred';

  let html = '';

  // Title + toggle
  html += `<div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
    <h2 style="font-size:16px;color:var(--bright)">${uc.label}: ${uc.title}</h2>
    <div class="toggle-bar">
      <button class="toggle-btn${v === 'single' ? ' active' : ''}" onclick="setView('single')">Single</button>
      <button class="toggle-btn${v === 'mapped' ? ' active' : ''}" onclick="setView('mapped')">Mapped</button>
      <button class="toggle-btn${v === 'nested' ? ' active' : ''}" onclick="setView('nested')">Nested</button>
    </div>
  </div>`;

  const pyCode = v === 'single' ? uc.single_python
               : v === 'mapped' ? uc.mapped_python
               : uc.nested_python;
  const cliCode = v === 'single' ? uc.single_cli
                : v === 'mapped' ? uc.mapped_cli
                : uc.nested_cli;

  // Python section
  if (pyCode) {
    const badge = v === 'single'
      ? '<span class="badge" style="background:#0d2818;color:var(--green)">single item</span>'
      : v === 'mapped'
      ? '<span class="badge" style="background:#21162a;color:var(--purple)">runner.map()</span>'
      : '<span class="badge" style="background:#0a2a2a;color:var(--cyan)">map_over</span>';
    html += `<div class="section">
      <div class="sec-hdr">
        <div class="dot" style="background:var(--green)"></div>
        <h3>Python API</h3>
        ${badge}
      </div>
      <pre class="code"><code class="language-python">${pyCode}</code></pre>
    </div>`;
  }

  // CLI section
  if (cliCode) {
    html += `<div class="section">
      <div class="sec-hdr">
        <div class="dot" style="background:var(--cyan)"></div>
        <h3>CLI</h3>
        <span class="badge" style="background:#0a1a2e;color:var(--cyan)">post-hoc</span>
      </div>
      <pre class="code"><code class="language-bash">${cliCode}</code></pre>
    </div>`;
  }

  // Implementation note
  html += `<div class="section">
    <div class="impl-note ${implCls}">
      <span class="label">${implLabel}:</span> ${uc.impl_note}
    </div>
  </div>`;

  m.innerHTML = html;
  if (typeof Prism !== 'undefined') Prism.highlightAllUnder(m);
}

render();
</script>
</body>
</html>