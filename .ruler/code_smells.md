- `sys.path.append(...)` (import-path hacking) - runtime import-path tweak usually means the project isn’t packaged/run correctly (wrong working dir, missing install, ad-hoc scripts/tests). **Prefer:** proper pyproject.toml layout, install the project (editable) / configure runner instead of mutating `sys.path`.
1. using "hasattr()" or "isinstance()" for deciding if some feature can be used
2. Docstrings shouldn't describe the code (e.g. "checks for 1, 2, 3... then does 4". then we need to always update it (WET).
3. if a class/dataclass has more than one item that is conditional. For example - RunResult dataclass that has paused_reason, pause_node, pause_value etc... when pausing has not necessarily happened.
4. Optional values in a dataclass/pydantic class that don't have existence or type assertion might cause linting errors and real bugs during runtime. (e.g. Response that has "cited_answer : str | None" and then if "ok" in response.cited_answer" - that's a bug/issue)
5. **God object (a.k.a. “blob” / “large class”)** – one class/module does *everything* (business logic, I/O, validation, persistence). Split by responsibility. ([ArjanCodes](https://arjancodes.com/blog/best-practices-for-eliminating-python-code-smells/))
6. **Duplicate code** – copy/paste logic that drifts over time. Extract helpers, consolidate flows. ([ArjanCodes](https://arjancodes.com/blog/best-practices-for-eliminating-python-code-smells/))
7. A class that has only one or two functions and no state - should probably be a function(s)
8. **Long method / function** – “does 10 steps” and is hard to test. Break into smaller functions with clear names. ([ArjanCodes](https://arjancodes.com/blog/best-practices-for-eliminating-python-code-smells/))
9. **Magic numbers / magic strings** – unexplained literals (`1.25`, `"PENDING_V2"`) sprinkled around. Use constants/enums/config. ([ArjanCodes](https://arjancodes.com/blog/best-practices-for-eliminating-python-code-smells/))
10. **Nested conditionals / deep indentation** – logic becomes a maze. Prefer guard clauses, `all()/any()`, polymorphism/strategies where appropriate. ([ArjanCodes](https://arjancodes.com/blog/best-practices-for-eliminating-python-code-smells/))
11. **Long parameter list** – many arguments often signals missing abstraction (group into dataclass/value object). ([Refactoring Guru](https://refactoring.guru/refactoring/smells?utm_source=chatgpt.com))
12. **Flag arguments / “switch statements” inside functions** – `do_thing(x, fast=True, verbose=False, mode="B")` then a pile of `if`s. Split into separate functions or use Strategy at construction time. ([Deliberate Machine Learning](https://laszlo.substack.com/p/what-is-a-code-smell-and-what-can))
13. **Shotgun surgery** – one change requires edits in many files/places. Centralize the knowledge; reduce coupling. ([Deliberate Machine Learning](https://laszlo.substack.com/p/what-is-a-code-smell-and-what-can))
14. **Feature envy** – method lives on class A but mostly manipulates class B’s data. Move behavior closer to the data it uses. ([Deliberate Machine Learning](https://laszlo.substack.com/p/what-is-a-code-smell-and-what-can))
15. **Inappropriate intimacy** – classes/functions reach into each other’s internals (tight coupling, leaky encapsulation). Refactor boundaries. ([Deliberate Machine Learning](https://laszlo.substack.com/p/what-is-a-code-smell-and-what-can))
16. **Primitive obsession** – using raw strings/ints/dicts where a domain type would prevent bugs (e.g., `user_id: str` everywhere instead of `UserId`). ([Refactoring Guru](https://refactoring.guru/refactoring/smells?utm_source=chatgpt.com))
17. **Data clumps** – the same group of variables travels together (`x,y,z` or `start,end,tz`) across many functions. Bundle into an object. ([Refactoring Guru](https://refactoring.guru/refactoring/smells?utm_source=chatgpt.com))
18. **Dead code / unused branches** – old paths, unused functions, “maybe later” scaffolding. Delete it; rely on version control. ([Deliberate Machine Learning](https://laszlo.substack.com/p/what-is-a-code-smell-and-what-can))
19. **Speculative generality (YAGNI)** – building frameworks/abstractions “just in case”. Keep it simple until requirements force it. ([Deliberate Machine Learning](https://laszlo.substack.com/p/what-is-a-code-smell-and-what-can))
20. **Comments that explain *what* instead of *why*** (or comments that drift from reality). Aim for self-documenting code; keep only “why”/constraints. ([Deliberate Machine Learning](https://laszlo.substack.com/p/what-is-a-code-smell-and-what-can))
- Python-specific “smells you see a lot”
1. **Bare `except:` / overly broad exception handling** – hides real failures (and can catch `KeyboardInterrupt`/`SystemExit`). Catch specific exceptions (or at least `Exception`) and keep `try` blocks tight. ([Python Enhancement Proposals (PEPs)](https://peps.python.org/pep-0760/?utm_source=chatgpt.com))
2. **Mutable default arguments** – `def f(x, cache=[]): ...` causes state to leak across calls. Use `None` + initialize inside. ([Discussions on Python.org](https://discuss.python.org/t/revisit-mutable-default-arguments/37525?utm_source=chatgpt.com))
3. **Global state / hidden dependencies** – functions rely on globals or module-level singletons, making behavior implicit and tests painful. Pass dependencies explicitly / encapsulate state. ([Stack Overflow](https://stackoverflow.com/questions/19158339/why-are-global-variables-evil?utm_source=chatgpt.com))